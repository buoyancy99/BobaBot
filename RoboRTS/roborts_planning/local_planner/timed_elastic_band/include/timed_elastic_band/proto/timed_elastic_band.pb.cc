// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "timed_elastic_band.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace roborts_local_planner {

namespace {

const ::google::protobuf::Descriptor* FrameID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameID_reflection_ = NULL;
const ::google::protobuf::Descriptor* Point2D_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point2D_reflection_ = NULL;
const ::google::protobuf::Descriptor* Trajectory_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Trajectory_reflection_ = NULL;
const ::google::protobuf::Descriptor* FootprintModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FootprintModel_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FootprintModel_FootprintType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Robot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Robot_reflection_ = NULL;
const ::google::protobuf::Descriptor* GoalTolerance_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GoalTolerance_reflection_ = NULL;
const ::google::protobuf::Descriptor* Obstacles_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Obstacles_reflection_ = NULL;
const ::google::protobuf::Descriptor* Optimization_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Optimization_reflection_ = NULL;
const ::google::protobuf::Descriptor* HomotopyClassPlanner_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HomotopyClassPlanner_reflection_ = NULL;
const ::google::protobuf::Descriptor* Recovery_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Recovery_reflection_ = NULL;
const ::google::protobuf::Descriptor* Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Config_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_timed_5felastic_5fband_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_timed_5felastic_5fband_2eproto() {
  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "timed_elastic_band.proto");
  GOOGLE_CHECK(file != NULL);
  FrameID_descriptor_ = file->message_type(0);
  static const int FrameID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameID, odom_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameID, map_frame_),
  };
  FrameID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FrameID_descriptor_,
      FrameID::default_instance_,
      FrameID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameID, _has_bits_[0]),
      -1,
      -1,
      sizeof(FrameID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameID, _internal_metadata_),
      -1);
  Point2D_descriptor_ = file->message_type(1);
  static const int Point2D_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point2D, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point2D, y_),
  };
  Point2D_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Point2D_descriptor_,
      Point2D::default_instance_,
      Point2D_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point2D, _has_bits_[0]),
      -1,
      -1,
      sizeof(Point2D),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point2D, _internal_metadata_),
      -1);
  Trajectory_descriptor_ = file->message_type(2);
  static const int Trajectory_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, teb_autosize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, dt_ref_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, dt_hysteresis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, global_plan_overwrite_orientation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, allow_init_with_backwards_motion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, global_plan_viapoint_sep_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, via_points_ordered_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, max_global_plan_lookahead_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, exact_arc_length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, force_reinit_new_goal_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, feasibility_check_no_poses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, publish_feedback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, min_samples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, max_samples_),
  };
  Trajectory_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Trajectory_descriptor_,
      Trajectory::default_instance_,
      Trajectory_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, _has_bits_[0]),
      -1,
      -1,
      sizeof(Trajectory),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trajectory, _internal_metadata_),
      -1);
  FootprintModel_descriptor_ = file->message_type(3);
  static const int FootprintModel_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, front_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, front_radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, rear_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, rear_radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, robot_vertices_),
  };
  FootprintModel_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FootprintModel_descriptor_,
      FootprintModel::default_instance_,
      FootprintModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, _has_bits_[0]),
      -1,
      -1,
      sizeof(FootprintModel),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FootprintModel, _internal_metadata_),
      -1);
  FootprintModel_FootprintType_descriptor_ = FootprintModel_descriptor_->enum_type(0);
  Robot_descriptor_ = file->message_type(4);
  static const int Robot_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, max_vel_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, max_vel_x_backwards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, max_vel_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, max_vel_theta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, acc_lim_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, acc_lim_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, acc_lim_theta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, min_turning_radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, wheelbase_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, cmd_angle_instead_rotvel_),
  };
  Robot_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Robot_descriptor_,
      Robot::default_instance_,
      Robot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _has_bits_[0]),
      -1,
      -1,
      sizeof(Robot),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _internal_metadata_),
      -1);
  GoalTolerance_descriptor_ = file->message_type(5);
  static const int GoalTolerance_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GoalTolerance, xy_goal_tolerance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GoalTolerance, yaw_goal_tolerance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GoalTolerance, free_goal_vel_),
  };
  GoalTolerance_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GoalTolerance_descriptor_,
      GoalTolerance::default_instance_,
      GoalTolerance_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GoalTolerance, _has_bits_[0]),
      -1,
      -1,
      sizeof(GoalTolerance),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GoalTolerance, _internal_metadata_),
      -1);
  Obstacles_descriptor_ = file->message_type(6);
  static const int Obstacles_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, min_obstacle_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, inflation_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, include_costmap_obstacles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, costmap_obstacles_behind_robot_dist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, obstacle_poses_affected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, legacy_obstacle_association_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, obstacle_association_cutoff_factor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, obstacle_association_force_inclusion_factor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, costmap_converter_plugin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, costmap_converter_spin_thread_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, costmap_converter_rate_),
  };
  Obstacles_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Obstacles_descriptor_,
      Obstacles::default_instance_,
      Obstacles_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, _has_bits_[0]),
      -1,
      -1,
      sizeof(Obstacles),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, _internal_metadata_),
      -1);
  Optimization_descriptor_ = file->message_type(7);
  static const int Optimization_offsets_[22] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, no_inner_iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, no_outer_iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, optimization_activate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, optimization_verbose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, penalty_epsilon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_max_vel_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_max_vel_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_max_vel_theta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_acc_lim_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_acc_lim_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_acc_lim_thet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_kinematics_nh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_kinematics_forward_drive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_kinematics_turning_radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_optimaltime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_obstacle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_inflation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_dynamic_obstacle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_viapoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_adapt_factor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_prefer_rotdir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, weight_acc_lim_theta_),
  };
  Optimization_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Optimization_descriptor_,
      Optimization::default_instance_,
      Optimization_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, _has_bits_[0]),
      -1,
      -1,
      sizeof(Optimization),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Optimization, _internal_metadata_),
      -1);
  HomotopyClassPlanner_descriptor_ = file->message_type(8);
  static const int HomotopyClassPlanner_offsets_[18] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, enable_homotopy_class_planning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, enable_multithreading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, simple_exploration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, max_number_classes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, selection_obst_cost_scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, selection_prefer_initial_plan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, selection_viapoint_cost_scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, selection_cost_hysteresis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, selection_alternative_time_cost_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, roadmap_graph_no_samples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, roadmap_graph_area_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, roadmap_graph_area_length_scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, h_signature_prescaler_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, h_signature_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, obstacle_keypoint_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, obstacle_heading_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, viapoints_all_candidates_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, visualize_hc_graph_),
  };
  HomotopyClassPlanner_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HomotopyClassPlanner_descriptor_,
      HomotopyClassPlanner::default_instance_,
      HomotopyClassPlanner_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, _has_bits_[0]),
      -1,
      -1,
      sizeof(HomotopyClassPlanner),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HomotopyClassPlanner, _internal_metadata_),
      -1);
  Recovery_descriptor_ = file->message_type(9);
  static const int Recovery_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, shrink_horizon_min_duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, oscillation_recovery_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, shrink_horizon_backup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, oscillation_v_eps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, oscillation_omega_eps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, oscillation_recovery_min_duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, oscillation_filter_duration_),
  };
  Recovery_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Recovery_descriptor_,
      Recovery::default_instance_,
      Recovery_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, _has_bits_[0]),
      -1,
      -1,
      sizeof(Recovery),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Recovery, _internal_metadata_),
      -1);
  Config_descriptor_ = file->message_type(10);
  static const int Config_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, opt_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, trajectory_opt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, kinematics_opt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, tolerance_opt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, obstacles_opt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, optimize_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, hcp_opt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, robot_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, recovery_info_),
  };
  Config_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Config_descriptor_,
      Config::default_instance_,
      Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _has_bits_[0]),
      -1,
      -1,
      sizeof(Config),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_timed_5felastic_5fband_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FrameID_descriptor_, &FrameID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Point2D_descriptor_, &Point2D::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Trajectory_descriptor_, &Trajectory::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FootprintModel_descriptor_, &FootprintModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Robot_descriptor_, &Robot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GoalTolerance_descriptor_, &GoalTolerance::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Obstacles_descriptor_, &Obstacles::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Optimization_descriptor_, &Optimization::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HomotopyClassPlanner_descriptor_, &HomotopyClassPlanner::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Recovery_descriptor_, &Recovery::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Config_descriptor_, &Config::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto() {
  delete FrameID::default_instance_;
  delete FrameID_reflection_;
  delete Point2D::default_instance_;
  delete Point2D_reflection_;
  delete Trajectory::default_instance_;
  delete Trajectory_reflection_;
  delete FootprintModel::default_instance_;
  delete FootprintModel_reflection_;
  delete Robot::default_instance_;
  delete Robot_reflection_;
  delete GoalTolerance::default_instance_;
  delete GoalTolerance_reflection_;
  delete Obstacles::default_instance_;
  delete Obstacles_reflection_;
  delete Optimization::default_instance_;
  delete Optimization_reflection_;
  delete HomotopyClassPlanner::default_instance_;
  delete HomotopyClassPlanner_reflection_;
  delete Recovery::default_instance_;
  delete Recovery_reflection_;
  delete Config::default_instance_;
  delete Config_reflection_;
}

void protobuf_AddDesc_timed_5felastic_5fband_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_timed_5felastic_5fband_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\030timed_elastic_band.proto\022\025roborts_loca"
    "l_planner\"0\n\007FrameID\022\022\n\nodom_frame\030\001 \001(\t"
    "\022\021\n\tmap_frame\030\002 \001(\t\"\037\n\007Point2D\022\t\n\001x\030\001 \001("
    "\002\022\t\n\001y\030\002 \001(\002\"\252\003\n\nTrajectory\022\024\n\014teb_autos"
    "ize\030\001 \001(\010\022\016\n\006dt_ref\030\002 \001(\002\022\025\n\rdt_hysteres"
    "is\030\003 \001(\002\022)\n!global_plan_overwrite_orient"
    "ation\030\004 \001(\010\022(\n allow_init_with_backwards"
    "_motion\030\005 \001(\010\022 \n\030global_plan_viapoint_se"
    "p\030\006 \001(\002\022\032\n\022via_points_ordered\030\007 \001(\010\022&\n\036m"
    "ax_global_plan_lookahead_dist\030\010 \001(\002\022\030\n\020e"
    "xact_arc_length\030\t \001(\010\022\"\n\032force_reinit_ne"
    "w_goal_dist\030\n \001(\002\022\"\n\032feasibility_check_n"
    "o_poses\030\013 \001(\003\022\030\n\020publish_feedback\030\014 \001(\010\022"
    "\023\n\013min_samples\030\r \001(\003\022\023\n\013max_samples\030\016 \001("
    "\003\"\302\002\n\016FootprintModel\022A\n\004type\030\001 \001(\01623.rob"
    "orts_local_planner.FootprintModel.Footpr"
    "intType\022\016\n\006radius\030\002 \001(\001\022\024\n\014front_offset\030"
    "\003 \001(\001\022\024\n\014front_radius\030\004 \001(\001\022\023\n\013rear_offs"
    "et\030\005 \001(\001\022\023\n\013rear_radius\030\006 \001(\001\0226\n\016robot_v"
    "ertices\030\007 \003(\0132\036.roborts_local_planner.Po"
    "int2D\"O\n\rFootprintType\022\t\n\005POINT\020\000\022\014\n\010CIR"
    "CULAR\020\001\022\016\n\nTWOCIRCLES\020\002\022\010\n\004LINE\020\003\022\013\n\007POL"
    "YGON\020\004\"\357\001\n\005Robot\022\021\n\tmax_vel_x\030\001 \001(\002\022\033\n\023m"
    "ax_vel_x_backwards\030\002 \001(\002\022\021\n\tmax_vel_y\030\003 "
    "\001(\002\022\025\n\rmax_vel_theta\030\004 \001(\002\022\021\n\tacc_lim_x\030"
    "\005 \001(\002\022\021\n\tacc_lim_y\030\006 \001(\002\022\025\n\racc_lim_thet"
    "a\030\007 \001(\002\022\032\n\022min_turning_radius\030\010 \001(\002\022\021\n\tw"
    "heelbase\030\t \001(\002\022 \n\030cmd_angle_instead_rotv"
    "el\030\n \001(\010\"]\n\rGoalTolerance\022\031\n\021xy_goal_tol"
    "erance\030\001 \001(\002\022\032\n\022yaw_goal_tolerance\030\002 \001(\002"
    "\022\025\n\rfree_goal_vel\030\003 \001(\010\"\236\003\n\tObstacles\022\031\n"
    "\021min_obstacle_dist\030\001 \001(\002\022\026\n\016inflation_di"
    "st\030\002 \001(\002\022!\n\031include_costmap_obstacles\030\003 "
    "\001(\010\022+\n#costmap_obstacles_behind_robot_di"
    "st\030\004 \001(\002\022\037\n\027obstacle_poses_affected\030\005 \001("
    "\002\022#\n\033legacy_obstacle_association\030\006 \001(\010\022*"
    "\n\"obstacle_association_cutoff_factor\030\007 \001"
    "(\002\0223\n+obstacle_association_force_inclusi"
    "on_factor\030\010 \001(\002\022 \n\030costmap_converter_plu"
    "gin\030\t \001(\t\022%\n\035costmap_converter_spin_thre"
    "ad\030\n \001(\010\022\036\n\026costmap_converter_rate\030\013 \001(\002"
    "\"\224\005\n\014Optimization\022\033\n\023no_inner_iterations"
    "\030\001 \001(\005\022\033\n\023no_outer_iterations\030\002 \001(\005\022\035\n\025o"
    "ptimization_activate\030\003 \001(\010\022\034\n\024optimizati"
    "on_verbose\030\004 \001(\010\022\027\n\017penalty_epsilon\030\005 \001("
    "\002\022\030\n\020weight_max_vel_x\030\006 \001(\002\022\030\n\020weight_ma"
    "x_vel_y\030\007 \001(\002\022\034\n\024weight_max_vel_theta\030\010 "
    "\001(\002\022\030\n\020weight_acc_lim_x\030\t \001(\002\022\030\n\020weight_"
    "acc_lim_y\030\n \001(\002\022\033\n\023weight_acc_lim_thet\030\013"
    " \001(\002\022\034\n\024weight_kinematics_nh\030\014 \001(\002\022\'\n\037we"
    "ight_kinematics_forward_drive\030\r \001(\002\022(\n w"
    "eight_kinematics_turning_radius\030\016 \001(\002\022\032\n"
    "\022weight_optimaltime\030\017 \001(\002\022\027\n\017weight_obst"
    "acle\030\020 \001(\002\022\030\n\020weight_inflation\030\021 \001(\002\022\037\n\027"
    "weight_dynamic_obstacle\030\022 \001(\002\022\027\n\017weight_"
    "viapoint\030\023 \001(\002\022\033\n\023weight_adapt_factor\030\024 "
    "\001(\002\022\034\n\024weight_prefer_rotdir\030\025 \001(\002\022\034\n\024wei"
    "ght_acc_lim_theta\030\026 \001(\002\"\201\005\n\024HomotopyClas"
    "sPlanner\022&\n\036enable_homotopy_class_planni"
    "ng\030\001 \001(\010\022\035\n\025enable_multithreading\030\002 \001(\010\022"
    "\032\n\022simple_exploration\030\003 \001(\010\022\032\n\022max_numbe"
    "r_classes\030\004 \001(\005\022!\n\031selection_obst_cost_s"
    "cale\030\005 \001(\002\022%\n\035selection_prefer_initial_p"
    "lan\030\006 \001(\002\022%\n\035selection_viapoint_cost_sca"
    "le\030\007 \001(\002\022!\n\031selection_cost_hysteresis\030\010 "
    "\001(\002\022\'\n\037selection_alternative_time_cost\030\t"
    " \001(\010\022 \n\030roadmap_graph_no_samples\030\n \001(\005\022 "
    "\n\030roadmap_graph_area_width\030\013 \001(\005\022\'\n\037road"
    "map_graph_area_length_scale\030\014 \001(\002\022\035\n\025h_s"
    "ignature_prescaler\030\r \001(\002\022\035\n\025h_signature_"
    "threshold\030\016 \001(\002\022 \n\030obstacle_keypoint_off"
    "set\030\017 \001(\002\022\"\n\032obstacle_heading_threshold\030"
    "\020 \001(\002\022 \n\030viapoints_all_candidates\030\021 \001(\010\022"
    "\032\n\022visualize_hc_graph\030\022 \001(\010\"\366\001\n\010Recovery"
    "\022#\n\033shrink_horizon_min_duration\030\001 \001(\010\022\034\n"
    "\024oscillation_recovery\030\002 \001(\010\022\035\n\025shrink_ho"
    "rizon_backup\030\003 \001(\010\022\031\n\021oscillation_v_eps\030"
    "\004 \001(\001\022\035\n\025oscillation_omega_eps\030\005 \001(\001\022)\n!"
    "oscillation_recovery_min_duration\030\006 \001(\001\022"
    "#\n\033oscillation_filter_duration\030\007 \001(\001\"\217\004\n"
    "\006Config\0221\n\topt_frame\030\001 \001(\0132\036.roborts_loc"
    "al_planner.FrameID\0229\n\016trajectory_opt\030\002 \001"
    "(\0132!.roborts_local_planner.Trajectory\0224\n"
    "\016kinematics_opt\030\003 \001(\0132\034.roborts_local_pl"
    "anner.Robot\022;\n\rtolerance_opt\030\004 \001(\0132$.rob"
    "orts_local_planner.GoalTolerance\0227\n\robst"
    "acles_opt\030\005 \001(\0132 .roborts_local_planner."
    "Obstacles\022:\n\roptimize_info\030\006 \001(\0132#.robor"
    "ts_local_planner.Optimization\022<\n\007hcp_opt"
    "\030\007 \001(\0132+.roborts_local_planner.HomotopyC"
    "lassPlanner\0229\n\nrobot_type\030\010 \003(\0132%.robort"
    "s_local_planner.FootprintModel\0226\n\rrecove"
    "ry_info\030\t \001(\0132\037.roborts_local_planner.Re"
    "covery", 3726);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "timed_elastic_band.proto", &protobuf_RegisterTypes);
  FrameID::default_instance_ = new FrameID();
  Point2D::default_instance_ = new Point2D();
  Trajectory::default_instance_ = new Trajectory();
  FootprintModel::default_instance_ = new FootprintModel();
  Robot::default_instance_ = new Robot();
  GoalTolerance::default_instance_ = new GoalTolerance();
  Obstacles::default_instance_ = new Obstacles();
  Optimization::default_instance_ = new Optimization();
  HomotopyClassPlanner::default_instance_ = new HomotopyClassPlanner();
  Recovery::default_instance_ = new Recovery();
  Config::default_instance_ = new Config();
  FrameID::default_instance_->InitAsDefaultInstance();
  Point2D::default_instance_->InitAsDefaultInstance();
  Trajectory::default_instance_->InitAsDefaultInstance();
  FootprintModel::default_instance_->InitAsDefaultInstance();
  Robot::default_instance_->InitAsDefaultInstance();
  GoalTolerance::default_instance_->InitAsDefaultInstance();
  Obstacles::default_instance_->InitAsDefaultInstance();
  Optimization::default_instance_->InitAsDefaultInstance();
  HomotopyClassPlanner::default_instance_->InitAsDefaultInstance();
  Recovery::default_instance_->InitAsDefaultInstance();
  Config::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_timed_5felastic_5fband_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_timed_5felastic_5fband_2eproto {
  StaticDescriptorInitializer_timed_5felastic_5fband_2eproto() {
    protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  }
} static_descriptor_initializer_timed_5felastic_5fband_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameID::kOdomFrameFieldNumber;
const int FrameID::kMapFrameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameID::FrameID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.FrameID)
}

void FrameID::InitAsDefaultInstance() {
}

FrameID::FrameID(const FrameID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.FrameID)
}

void FrameID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  odom_frame_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  map_frame_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameID::~FrameID() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.FrameID)
  SharedDtor();
}

void FrameID::SharedDtor() {
  odom_frame_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  map_frame_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void FrameID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameID_descriptor_;
}

const FrameID& FrameID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

FrameID* FrameID::default_instance_ = NULL;

FrameID* FrameID::New(::google::protobuf::Arena* arena) const {
  FrameID* n = new FrameID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameID::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.FrameID)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_odom_frame()) {
      odom_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_map_frame()) {
      map_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FrameID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.FrameID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string odom_frame = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_odom_frame()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->odom_frame().data(), this->odom_frame().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roborts_local_planner.FrameID.odom_frame");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_map_frame;
        break;
      }

      // optional string map_frame = 2;
      case 2: {
        if (tag == 18) {
         parse_map_frame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_map_frame()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->map_frame().data(), this->map_frame().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roborts_local_planner.FrameID.map_frame");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.FrameID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.FrameID)
  return false;
#undef DO_
}

void FrameID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.FrameID)
  // optional string odom_frame = 1;
  if (has_odom_frame()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->odom_frame().data(), this->odom_frame().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.odom_frame");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->odom_frame(), output);
  }

  // optional string map_frame = 2;
  if (has_map_frame()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->map_frame().data(), this->map_frame().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.map_frame");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->map_frame(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.FrameID)
}

::google::protobuf::uint8* FrameID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.FrameID)
  // optional string odom_frame = 1;
  if (has_odom_frame()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->odom_frame().data(), this->odom_frame().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.odom_frame");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->odom_frame(), target);
  }

  // optional string map_frame = 2;
  if (has_map_frame()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->map_frame().data(), this->map_frame().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.FrameID.map_frame");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->map_frame(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.FrameID)
  return target;
}

int FrameID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.FrameID)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string odom_frame = 1;
    if (has_odom_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->odom_frame());
    }

    // optional string map_frame = 2;
    if (has_map_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->map_frame());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.FrameID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FrameID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FrameID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.FrameID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.FrameID)
    MergeFrom(*source);
  }
}

void FrameID::MergeFrom(const FrameID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.FrameID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_odom_frame()) {
      set_has_odom_frame();
      odom_frame_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.odom_frame_);
    }
    if (from.has_map_frame()) {
      set_has_map_frame();
      map_frame_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.map_frame_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FrameID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.FrameID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameID::CopyFrom(const FrameID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.FrameID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameID::IsInitialized() const {

  return true;
}

void FrameID::Swap(FrameID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameID::InternalSwap(FrameID* other) {
  odom_frame_.Swap(&other->odom_frame_);
  map_frame_.Swap(&other->map_frame_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FrameID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameID_descriptor_;
  metadata.reflection = FrameID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FrameID

// optional string odom_frame = 1;
bool FrameID::has_odom_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FrameID::set_has_odom_frame() {
  _has_bits_[0] |= 0x00000001u;
}
void FrameID::clear_has_odom_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
void FrameID::clear_odom_frame() {
  odom_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_odom_frame();
}
 const ::std::string& FrameID::odom_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.odom_frame)
  return odom_frame_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameID::set_odom_frame(const ::std::string& value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.odom_frame)
}
 void FrameID::set_odom_frame(const char* value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.FrameID.odom_frame)
}
 void FrameID::set_odom_frame(const char* value, size_t size) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.FrameID.odom_frame)
}
 ::std::string* FrameID::mutable_odom_frame() {
  set_has_odom_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.odom_frame)
  return odom_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameID::release_odom_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.odom_frame)
  clear_has_odom_frame();
  return odom_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameID::set_allocated_odom_frame(::std::string* odom_frame) {
  if (odom_frame != NULL) {
    set_has_odom_frame();
  } else {
    clear_has_odom_frame();
  }
  odom_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), odom_frame);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.odom_frame)
}

// optional string map_frame = 2;
bool FrameID::has_map_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FrameID::set_has_map_frame() {
  _has_bits_[0] |= 0x00000002u;
}
void FrameID::clear_has_map_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
void FrameID::clear_map_frame() {
  map_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_frame();
}
 const ::std::string& FrameID::map_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.map_frame)
  return map_frame_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameID::set_map_frame(const ::std::string& value) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.map_frame)
}
 void FrameID::set_map_frame(const char* value) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.FrameID.map_frame)
}
 void FrameID::set_map_frame(const char* value, size_t size) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.FrameID.map_frame)
}
 ::std::string* FrameID::mutable_map_frame() {
  set_has_map_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.map_frame)
  return map_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameID::release_map_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.map_frame)
  clear_has_map_frame();
  return map_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameID::set_allocated_map_frame(::std::string* map_frame) {
  if (map_frame != NULL) {
    set_has_map_frame();
  } else {
    clear_has_map_frame();
  }
  map_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_frame);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.map_frame)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point2D::kXFieldNumber;
const int Point2D::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point2D::Point2D()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Point2D)
}

void Point2D::InitAsDefaultInstance() {
}

Point2D::Point2D(const Point2D& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Point2D)
}

void Point2D::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point2D::~Point2D() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Point2D)
  SharedDtor();
}

void Point2D::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point2D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point2D::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point2D_descriptor_;
}

const Point2D& Point2D::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Point2D* Point2D::default_instance_ = NULL;

Point2D* Point2D::New(::google::protobuf::Arena* arena) const {
  Point2D* n = new Point2D;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Point2D::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Point2D)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Point2D, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Point2D*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, y_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Point2D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Point2D)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // optional float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Point2D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Point2D)
  return false;
#undef DO_
}

void Point2D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Point2D)
  // optional float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Point2D)
}

::google::protobuf::uint8* Point2D::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Point2D)
  // optional float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Point2D)
  return target;
}

int Point2D::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Point2D)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point2D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Point2D)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Point2D* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Point2D>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Point2D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Point2D)
    MergeFrom(*source);
  }
}

void Point2D::MergeFrom(const Point2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Point2D)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Point2D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Point2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point2D::CopyFrom(const Point2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Point2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point2D::IsInitialized() const {

  return true;
}

void Point2D::Swap(Point2D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point2D::InternalSwap(Point2D* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Point2D::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point2D_descriptor_;
  metadata.reflection = Point2D_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Point2D

// optional float x = 1;
bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Point2D::x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.x)
  return x_;
}
 void Point2D::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.x)
}

// optional float y = 2;
bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Point2D::y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.y)
  return y_;
}
 void Point2D::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Trajectory::kTebAutosizeFieldNumber;
const int Trajectory::kDtRefFieldNumber;
const int Trajectory::kDtHysteresisFieldNumber;
const int Trajectory::kGlobalPlanOverwriteOrientationFieldNumber;
const int Trajectory::kAllowInitWithBackwardsMotionFieldNumber;
const int Trajectory::kGlobalPlanViapointSepFieldNumber;
const int Trajectory::kViaPointsOrderedFieldNumber;
const int Trajectory::kMaxGlobalPlanLookaheadDistFieldNumber;
const int Trajectory::kExactArcLengthFieldNumber;
const int Trajectory::kForceReinitNewGoalDistFieldNumber;
const int Trajectory::kFeasibilityCheckNoPosesFieldNumber;
const int Trajectory::kPublishFeedbackFieldNumber;
const int Trajectory::kMinSamplesFieldNumber;
const int Trajectory::kMaxSamplesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Trajectory::Trajectory()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Trajectory)
}

void Trajectory::InitAsDefaultInstance() {
}

Trajectory::Trajectory(const Trajectory& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Trajectory)
}

void Trajectory::SharedCtor() {
  _cached_size_ = 0;
  teb_autosize_ = false;
  dt_ref_ = 0;
  dt_hysteresis_ = 0;
  global_plan_overwrite_orientation_ = false;
  allow_init_with_backwards_motion_ = false;
  global_plan_viapoint_sep_ = 0;
  via_points_ordered_ = false;
  max_global_plan_lookahead_dist_ = 0;
  exact_arc_length_ = false;
  force_reinit_new_goal_dist_ = 0;
  feasibility_check_no_poses_ = GOOGLE_LONGLONG(0);
  publish_feedback_ = false;
  min_samples_ = GOOGLE_LONGLONG(0);
  max_samples_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Trajectory::~Trajectory() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Trajectory)
  SharedDtor();
}

void Trajectory::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Trajectory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Trajectory::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Trajectory_descriptor_;
}

const Trajectory& Trajectory::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Trajectory* Trajectory::default_instance_ = NULL;

Trajectory* Trajectory::New(::google::protobuf::Arena* arena) const {
  Trajectory* n = new Trajectory;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Trajectory::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Trajectory)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Trajectory, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Trajectory*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(dt_ref_, max_global_plan_lookahead_dist_);
  }
  if (_has_bits_[8 / 32] & 16128u) {
    ZR_(force_reinit_new_goal_dist_, publish_feedback_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Trajectory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Trajectory)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool teb_autosize = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &teb_autosize_)));
          set_has_teb_autosize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_dt_ref;
        break;
      }

      // optional float dt_ref = 2;
      case 2: {
        if (tag == 21) {
         parse_dt_ref:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dt_ref_)));
          set_has_dt_ref();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_dt_hysteresis;
        break;
      }

      // optional float dt_hysteresis = 3;
      case 3: {
        if (tag == 29) {
         parse_dt_hysteresis:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dt_hysteresis_)));
          set_has_dt_hysteresis();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_global_plan_overwrite_orientation;
        break;
      }

      // optional bool global_plan_overwrite_orientation = 4;
      case 4: {
        if (tag == 32) {
         parse_global_plan_overwrite_orientation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &global_plan_overwrite_orientation_)));
          set_has_global_plan_overwrite_orientation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_allow_init_with_backwards_motion;
        break;
      }

      // optional bool allow_init_with_backwards_motion = 5;
      case 5: {
        if (tag == 40) {
         parse_allow_init_with_backwards_motion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_init_with_backwards_motion_)));
          set_has_allow_init_with_backwards_motion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_global_plan_viapoint_sep;
        break;
      }

      // optional float global_plan_viapoint_sep = 6;
      case 6: {
        if (tag == 53) {
         parse_global_plan_viapoint_sep:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &global_plan_viapoint_sep_)));
          set_has_global_plan_viapoint_sep();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_via_points_ordered;
        break;
      }

      // optional bool via_points_ordered = 7;
      case 7: {
        if (tag == 56) {
         parse_via_points_ordered:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &via_points_ordered_)));
          set_has_via_points_ordered();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_max_global_plan_lookahead_dist;
        break;
      }

      // optional float max_global_plan_lookahead_dist = 8;
      case 8: {
        if (tag == 69) {
         parse_max_global_plan_lookahead_dist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_global_plan_lookahead_dist_)));
          set_has_max_global_plan_lookahead_dist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_exact_arc_length;
        break;
      }

      // optional bool exact_arc_length = 9;
      case 9: {
        if (tag == 72) {
         parse_exact_arc_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &exact_arc_length_)));
          set_has_exact_arc_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_force_reinit_new_goal_dist;
        break;
      }

      // optional float force_reinit_new_goal_dist = 10;
      case 10: {
        if (tag == 85) {
         parse_force_reinit_new_goal_dist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &force_reinit_new_goal_dist_)));
          set_has_force_reinit_new_goal_dist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_feasibility_check_no_poses;
        break;
      }

      // optional int64 feasibility_check_no_poses = 11;
      case 11: {
        if (tag == 88) {
         parse_feasibility_check_no_poses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &feasibility_check_no_poses_)));
          set_has_feasibility_check_no_poses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_publish_feedback;
        break;
      }

      // optional bool publish_feedback = 12;
      case 12: {
        if (tag == 96) {
         parse_publish_feedback:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &publish_feedback_)));
          set_has_publish_feedback();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_min_samples;
        break;
      }

      // optional int64 min_samples = 13;
      case 13: {
        if (tag == 104) {
         parse_min_samples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &min_samples_)));
          set_has_min_samples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_max_samples;
        break;
      }

      // optional int64 max_samples = 14;
      case 14: {
        if (tag == 112) {
         parse_max_samples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_samples_)));
          set_has_max_samples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Trajectory)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Trajectory)
  return false;
#undef DO_
}

void Trajectory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Trajectory)
  // optional bool teb_autosize = 1;
  if (has_teb_autosize()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->teb_autosize(), output);
  }

  // optional float dt_ref = 2;
  if (has_dt_ref()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->dt_ref(), output);
  }

  // optional float dt_hysteresis = 3;
  if (has_dt_hysteresis()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->dt_hysteresis(), output);
  }

  // optional bool global_plan_overwrite_orientation = 4;
  if (has_global_plan_overwrite_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->global_plan_overwrite_orientation(), output);
  }

  // optional bool allow_init_with_backwards_motion = 5;
  if (has_allow_init_with_backwards_motion()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->allow_init_with_backwards_motion(), output);
  }

  // optional float global_plan_viapoint_sep = 6;
  if (has_global_plan_viapoint_sep()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->global_plan_viapoint_sep(), output);
  }

  // optional bool via_points_ordered = 7;
  if (has_via_points_ordered()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->via_points_ordered(), output);
  }

  // optional float max_global_plan_lookahead_dist = 8;
  if (has_max_global_plan_lookahead_dist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->max_global_plan_lookahead_dist(), output);
  }

  // optional bool exact_arc_length = 9;
  if (has_exact_arc_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->exact_arc_length(), output);
  }

  // optional float force_reinit_new_goal_dist = 10;
  if (has_force_reinit_new_goal_dist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->force_reinit_new_goal_dist(), output);
  }

  // optional int64 feasibility_check_no_poses = 11;
  if (has_feasibility_check_no_poses()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->feasibility_check_no_poses(), output);
  }

  // optional bool publish_feedback = 12;
  if (has_publish_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->publish_feedback(), output);
  }

  // optional int64 min_samples = 13;
  if (has_min_samples()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->min_samples(), output);
  }

  // optional int64 max_samples = 14;
  if (has_max_samples()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->max_samples(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Trajectory)
}

::google::protobuf::uint8* Trajectory::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Trajectory)
  // optional bool teb_autosize = 1;
  if (has_teb_autosize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->teb_autosize(), target);
  }

  // optional float dt_ref = 2;
  if (has_dt_ref()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->dt_ref(), target);
  }

  // optional float dt_hysteresis = 3;
  if (has_dt_hysteresis()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->dt_hysteresis(), target);
  }

  // optional bool global_plan_overwrite_orientation = 4;
  if (has_global_plan_overwrite_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->global_plan_overwrite_orientation(), target);
  }

  // optional bool allow_init_with_backwards_motion = 5;
  if (has_allow_init_with_backwards_motion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->allow_init_with_backwards_motion(), target);
  }

  // optional float global_plan_viapoint_sep = 6;
  if (has_global_plan_viapoint_sep()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->global_plan_viapoint_sep(), target);
  }

  // optional bool via_points_ordered = 7;
  if (has_via_points_ordered()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->via_points_ordered(), target);
  }

  // optional float max_global_plan_lookahead_dist = 8;
  if (has_max_global_plan_lookahead_dist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->max_global_plan_lookahead_dist(), target);
  }

  // optional bool exact_arc_length = 9;
  if (has_exact_arc_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->exact_arc_length(), target);
  }

  // optional float force_reinit_new_goal_dist = 10;
  if (has_force_reinit_new_goal_dist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->force_reinit_new_goal_dist(), target);
  }

  // optional int64 feasibility_check_no_poses = 11;
  if (has_feasibility_check_no_poses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->feasibility_check_no_poses(), target);
  }

  // optional bool publish_feedback = 12;
  if (has_publish_feedback()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->publish_feedback(), target);
  }

  // optional int64 min_samples = 13;
  if (has_min_samples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->min_samples(), target);
  }

  // optional int64 max_samples = 14;
  if (has_max_samples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->max_samples(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Trajectory)
  return target;
}

int Trajectory::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Trajectory)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional bool teb_autosize = 1;
    if (has_teb_autosize()) {
      total_size += 1 + 1;
    }

    // optional float dt_ref = 2;
    if (has_dt_ref()) {
      total_size += 1 + 4;
    }

    // optional float dt_hysteresis = 3;
    if (has_dt_hysteresis()) {
      total_size += 1 + 4;
    }

    // optional bool global_plan_overwrite_orientation = 4;
    if (has_global_plan_overwrite_orientation()) {
      total_size += 1 + 1;
    }

    // optional bool allow_init_with_backwards_motion = 5;
    if (has_allow_init_with_backwards_motion()) {
      total_size += 1 + 1;
    }

    // optional float global_plan_viapoint_sep = 6;
    if (has_global_plan_viapoint_sep()) {
      total_size += 1 + 4;
    }

    // optional bool via_points_ordered = 7;
    if (has_via_points_ordered()) {
      total_size += 1 + 1;
    }

    // optional float max_global_plan_lookahead_dist = 8;
    if (has_max_global_plan_lookahead_dist()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 16128u) {
    // optional bool exact_arc_length = 9;
    if (has_exact_arc_length()) {
      total_size += 1 + 1;
    }

    // optional float force_reinit_new_goal_dist = 10;
    if (has_force_reinit_new_goal_dist()) {
      total_size += 1 + 4;
    }

    // optional int64 feasibility_check_no_poses = 11;
    if (has_feasibility_check_no_poses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->feasibility_check_no_poses());
    }

    // optional bool publish_feedback = 12;
    if (has_publish_feedback()) {
      total_size += 1 + 1;
    }

    // optional int64 min_samples = 13;
    if (has_min_samples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->min_samples());
    }

    // optional int64 max_samples = 14;
    if (has_max_samples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_samples());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Trajectory::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Trajectory)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Trajectory* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Trajectory>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Trajectory)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Trajectory)
    MergeFrom(*source);
  }
}

void Trajectory::MergeFrom(const Trajectory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Trajectory)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_teb_autosize()) {
      set_teb_autosize(from.teb_autosize());
    }
    if (from.has_dt_ref()) {
      set_dt_ref(from.dt_ref());
    }
    if (from.has_dt_hysteresis()) {
      set_dt_hysteresis(from.dt_hysteresis());
    }
    if (from.has_global_plan_overwrite_orientation()) {
      set_global_plan_overwrite_orientation(from.global_plan_overwrite_orientation());
    }
    if (from.has_allow_init_with_backwards_motion()) {
      set_allow_init_with_backwards_motion(from.allow_init_with_backwards_motion());
    }
    if (from.has_global_plan_viapoint_sep()) {
      set_global_plan_viapoint_sep(from.global_plan_viapoint_sep());
    }
    if (from.has_via_points_ordered()) {
      set_via_points_ordered(from.via_points_ordered());
    }
    if (from.has_max_global_plan_lookahead_dist()) {
      set_max_global_plan_lookahead_dist(from.max_global_plan_lookahead_dist());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_exact_arc_length()) {
      set_exact_arc_length(from.exact_arc_length());
    }
    if (from.has_force_reinit_new_goal_dist()) {
      set_force_reinit_new_goal_dist(from.force_reinit_new_goal_dist());
    }
    if (from.has_feasibility_check_no_poses()) {
      set_feasibility_check_no_poses(from.feasibility_check_no_poses());
    }
    if (from.has_publish_feedback()) {
      set_publish_feedback(from.publish_feedback());
    }
    if (from.has_min_samples()) {
      set_min_samples(from.min_samples());
    }
    if (from.has_max_samples()) {
      set_max_samples(from.max_samples());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Trajectory::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Trajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Trajectory::CopyFrom(const Trajectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Trajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trajectory::IsInitialized() const {

  return true;
}

void Trajectory::Swap(Trajectory* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Trajectory::InternalSwap(Trajectory* other) {
  std::swap(teb_autosize_, other->teb_autosize_);
  std::swap(dt_ref_, other->dt_ref_);
  std::swap(dt_hysteresis_, other->dt_hysteresis_);
  std::swap(global_plan_overwrite_orientation_, other->global_plan_overwrite_orientation_);
  std::swap(allow_init_with_backwards_motion_, other->allow_init_with_backwards_motion_);
  std::swap(global_plan_viapoint_sep_, other->global_plan_viapoint_sep_);
  std::swap(via_points_ordered_, other->via_points_ordered_);
  std::swap(max_global_plan_lookahead_dist_, other->max_global_plan_lookahead_dist_);
  std::swap(exact_arc_length_, other->exact_arc_length_);
  std::swap(force_reinit_new_goal_dist_, other->force_reinit_new_goal_dist_);
  std::swap(feasibility_check_no_poses_, other->feasibility_check_no_poses_);
  std::swap(publish_feedback_, other->publish_feedback_);
  std::swap(min_samples_, other->min_samples_);
  std::swap(max_samples_, other->max_samples_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Trajectory::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Trajectory_descriptor_;
  metadata.reflection = Trajectory_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Trajectory

// optional bool teb_autosize = 1;
bool Trajectory::has_teb_autosize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Trajectory::set_has_teb_autosize() {
  _has_bits_[0] |= 0x00000001u;
}
void Trajectory::clear_has_teb_autosize() {
  _has_bits_[0] &= ~0x00000001u;
}
void Trajectory::clear_teb_autosize() {
  teb_autosize_ = false;
  clear_has_teb_autosize();
}
 bool Trajectory::teb_autosize() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.teb_autosize)
  return teb_autosize_;
}
 void Trajectory::set_teb_autosize(bool value) {
  set_has_teb_autosize();
  teb_autosize_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.teb_autosize)
}

// optional float dt_ref = 2;
bool Trajectory::has_dt_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Trajectory::set_has_dt_ref() {
  _has_bits_[0] |= 0x00000002u;
}
void Trajectory::clear_has_dt_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
void Trajectory::clear_dt_ref() {
  dt_ref_ = 0;
  clear_has_dt_ref();
}
 float Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_ref)
  return dt_ref_;
}
 void Trajectory::set_dt_ref(float value) {
  set_has_dt_ref();
  dt_ref_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_ref)
}

// optional float dt_hysteresis = 3;
bool Trajectory::has_dt_hysteresis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Trajectory::set_has_dt_hysteresis() {
  _has_bits_[0] |= 0x00000004u;
}
void Trajectory::clear_has_dt_hysteresis() {
  _has_bits_[0] &= ~0x00000004u;
}
void Trajectory::clear_dt_hysteresis() {
  dt_hysteresis_ = 0;
  clear_has_dt_hysteresis();
}
 float Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_hysteresis)
  return dt_hysteresis_;
}
 void Trajectory::set_dt_hysteresis(float value) {
  set_has_dt_hysteresis();
  dt_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_hysteresis)
}

// optional bool global_plan_overwrite_orientation = 4;
bool Trajectory::has_global_plan_overwrite_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Trajectory::set_has_global_plan_overwrite_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
void Trajectory::clear_has_global_plan_overwrite_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
void Trajectory::clear_global_plan_overwrite_orientation() {
  global_plan_overwrite_orientation_ = false;
  clear_has_global_plan_overwrite_orientation();
}
 bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
  return global_plan_overwrite_orientation_;
}
 void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  set_has_global_plan_overwrite_orientation();
  global_plan_overwrite_orientation_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 5;
bool Trajectory::has_allow_init_with_backwards_motion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Trajectory::set_has_allow_init_with_backwards_motion() {
  _has_bits_[0] |= 0x00000010u;
}
void Trajectory::clear_has_allow_init_with_backwards_motion() {
  _has_bits_[0] &= ~0x00000010u;
}
void Trajectory::clear_allow_init_with_backwards_motion() {
  allow_init_with_backwards_motion_ = false;
  clear_has_allow_init_with_backwards_motion();
}
 bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
  return allow_init_with_backwards_motion_;
}
 void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  set_has_allow_init_with_backwards_motion();
  allow_init_with_backwards_motion_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
}

// optional float global_plan_viapoint_sep = 6;
bool Trajectory::has_global_plan_viapoint_sep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Trajectory::set_has_global_plan_viapoint_sep() {
  _has_bits_[0] |= 0x00000020u;
}
void Trajectory::clear_has_global_plan_viapoint_sep() {
  _has_bits_[0] &= ~0x00000020u;
}
void Trajectory::clear_global_plan_viapoint_sep() {
  global_plan_viapoint_sep_ = 0;
  clear_has_global_plan_viapoint_sep();
}
 float Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
  return global_plan_viapoint_sep_;
}
 void Trajectory::set_global_plan_viapoint_sep(float value) {
  set_has_global_plan_viapoint_sep();
  global_plan_viapoint_sep_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 7;
bool Trajectory::has_via_points_ordered() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Trajectory::set_has_via_points_ordered() {
  _has_bits_[0] |= 0x00000040u;
}
void Trajectory::clear_has_via_points_ordered() {
  _has_bits_[0] &= ~0x00000040u;
}
void Trajectory::clear_via_points_ordered() {
  via_points_ordered_ = false;
  clear_has_via_points_ordered();
}
 bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.via_points_ordered)
  return via_points_ordered_;
}
 void Trajectory::set_via_points_ordered(bool value) {
  set_has_via_points_ordered();
  via_points_ordered_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.via_points_ordered)
}

// optional float max_global_plan_lookahead_dist = 8;
bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Trajectory::set_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] |= 0x00000080u;
}
void Trajectory::clear_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] &= ~0x00000080u;
}
void Trajectory::clear_max_global_plan_lookahead_dist() {
  max_global_plan_lookahead_dist_ = 0;
  clear_has_max_global_plan_lookahead_dist();
}
 float Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
  return max_global_plan_lookahead_dist_;
}
 void Trajectory::set_max_global_plan_lookahead_dist(float value) {
  set_has_max_global_plan_lookahead_dist();
  max_global_plan_lookahead_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
}

// optional bool exact_arc_length = 9;
bool Trajectory::has_exact_arc_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Trajectory::set_has_exact_arc_length() {
  _has_bits_[0] |= 0x00000100u;
}
void Trajectory::clear_has_exact_arc_length() {
  _has_bits_[0] &= ~0x00000100u;
}
void Trajectory::clear_exact_arc_length() {
  exact_arc_length_ = false;
  clear_has_exact_arc_length();
}
 bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.exact_arc_length)
  return exact_arc_length_;
}
 void Trajectory::set_exact_arc_length(bool value) {
  set_has_exact_arc_length();
  exact_arc_length_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.exact_arc_length)
}

// optional float force_reinit_new_goal_dist = 10;
bool Trajectory::has_force_reinit_new_goal_dist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Trajectory::set_has_force_reinit_new_goal_dist() {
  _has_bits_[0] |= 0x00000200u;
}
void Trajectory::clear_has_force_reinit_new_goal_dist() {
  _has_bits_[0] &= ~0x00000200u;
}
void Trajectory::clear_force_reinit_new_goal_dist() {
  force_reinit_new_goal_dist_ = 0;
  clear_has_force_reinit_new_goal_dist();
}
 float Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
  return force_reinit_new_goal_dist_;
}
 void Trajectory::set_force_reinit_new_goal_dist(float value) {
  set_has_force_reinit_new_goal_dist();
  force_reinit_new_goal_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
}

// optional int64 feasibility_check_no_poses = 11;
bool Trajectory::has_feasibility_check_no_poses() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Trajectory::set_has_feasibility_check_no_poses() {
  _has_bits_[0] |= 0x00000400u;
}
void Trajectory::clear_has_feasibility_check_no_poses() {
  _has_bits_[0] &= ~0x00000400u;
}
void Trajectory::clear_feasibility_check_no_poses() {
  feasibility_check_no_poses_ = GOOGLE_LONGLONG(0);
  clear_has_feasibility_check_no_poses();
}
 ::google::protobuf::int64 Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.feasibility_check_no_poses)
  return feasibility_check_no_poses_;
}
 void Trajectory::set_feasibility_check_no_poses(::google::protobuf::int64 value) {
  set_has_feasibility_check_no_poses();
  feasibility_check_no_poses_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 12;
bool Trajectory::has_publish_feedback() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Trajectory::set_has_publish_feedback() {
  _has_bits_[0] |= 0x00000800u;
}
void Trajectory::clear_has_publish_feedback() {
  _has_bits_[0] &= ~0x00000800u;
}
void Trajectory::clear_publish_feedback() {
  publish_feedback_ = false;
  clear_has_publish_feedback();
}
 bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.publish_feedback)
  return publish_feedback_;
}
 void Trajectory::set_publish_feedback(bool value) {
  set_has_publish_feedback();
  publish_feedback_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.publish_feedback)
}

// optional int64 min_samples = 13;
bool Trajectory::has_min_samples() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Trajectory::set_has_min_samples() {
  _has_bits_[0] |= 0x00001000u;
}
void Trajectory::clear_has_min_samples() {
  _has_bits_[0] &= ~0x00001000u;
}
void Trajectory::clear_min_samples() {
  min_samples_ = GOOGLE_LONGLONG(0);
  clear_has_min_samples();
}
 ::google::protobuf::int64 Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.min_samples)
  return min_samples_;
}
 void Trajectory::set_min_samples(::google::protobuf::int64 value) {
  set_has_min_samples();
  min_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.min_samples)
}

// optional int64 max_samples = 14;
bool Trajectory::has_max_samples() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Trajectory::set_has_max_samples() {
  _has_bits_[0] |= 0x00002000u;
}
void Trajectory::clear_has_max_samples() {
  _has_bits_[0] &= ~0x00002000u;
}
void Trajectory::clear_max_samples() {
  max_samples_ = GOOGLE_LONGLONG(0);
  clear_has_max_samples();
}
 ::google::protobuf::int64 Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_samples)
  return max_samples_;
}
 void Trajectory::set_max_samples(::google::protobuf::int64 value) {
  set_has_max_samples();
  max_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_samples)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* FootprintModel_FootprintType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FootprintModel_FootprintType_descriptor_;
}
bool FootprintModel_FootprintType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FootprintModel_FootprintType FootprintModel::POINT;
const FootprintModel_FootprintType FootprintModel::CIRCULAR;
const FootprintModel_FootprintType FootprintModel::TWOCIRCLES;
const FootprintModel_FootprintType FootprintModel::LINE;
const FootprintModel_FootprintType FootprintModel::POLYGON;
const FootprintModel_FootprintType FootprintModel::FootprintType_MIN;
const FootprintModel_FootprintType FootprintModel::FootprintType_MAX;
const int FootprintModel::FootprintType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FootprintModel::kTypeFieldNumber;
const int FootprintModel::kRadiusFieldNumber;
const int FootprintModel::kFrontOffsetFieldNumber;
const int FootprintModel::kFrontRadiusFieldNumber;
const int FootprintModel::kRearOffsetFieldNumber;
const int FootprintModel::kRearRadiusFieldNumber;
const int FootprintModel::kRobotVerticesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FootprintModel::FootprintModel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.FootprintModel)
}

void FootprintModel::InitAsDefaultInstance() {
}

FootprintModel::FootprintModel(const FootprintModel& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.FootprintModel)
}

void FootprintModel::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  radius_ = 0;
  front_offset_ = 0;
  front_radius_ = 0;
  rear_offset_ = 0;
  rear_radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FootprintModel::~FootprintModel() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.FootprintModel)
  SharedDtor();
}

void FootprintModel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FootprintModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FootprintModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FootprintModel_descriptor_;
}

const FootprintModel& FootprintModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

FootprintModel* FootprintModel::default_instance_ = NULL;

FootprintModel* FootprintModel::New(::google::protobuf::Arena* arena) const {
  FootprintModel* n = new FootprintModel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FootprintModel::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.FootprintModel)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FootprintModel, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FootprintModel*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(radius_, rear_radius_);
    type_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  robot_vertices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FootprintModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.FootprintModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::roborts_local_planner::FootprintModel_FootprintType_IsValid(value)) {
            set_type(static_cast< ::roborts_local_planner::FootprintModel_FootprintType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_radius;
        break;
      }

      // optional double radius = 2;
      case 2: {
        if (tag == 17) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_front_offset;
        break;
      }

      // optional double front_offset = 3;
      case 3: {
        if (tag == 25) {
         parse_front_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &front_offset_)));
          set_has_front_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_front_radius;
        break;
      }

      // optional double front_radius = 4;
      case 4: {
        if (tag == 33) {
         parse_front_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &front_radius_)));
          set_has_front_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_rear_offset;
        break;
      }

      // optional double rear_offset = 5;
      case 5: {
        if (tag == 41) {
         parse_rear_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rear_offset_)));
          set_has_rear_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_rear_radius;
        break;
      }

      // optional double rear_radius = 6;
      case 6: {
        if (tag == 49) {
         parse_rear_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rear_radius_)));
          set_has_rear_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_robot_vertices;
        break;
      }

      // repeated .roborts_local_planner.Point2D robot_vertices = 7;
      case 7: {
        if (tag == 58) {
         parse_robot_vertices:
          DO_(input->IncrementRecursionDepth());
         parse_loop_robot_vertices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_robot_vertices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_robot_vertices;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.FootprintModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.FootprintModel)
  return false;
#undef DO_
}

void FootprintModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.FootprintModel)
  // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional double radius = 2;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->radius(), output);
  }

  // optional double front_offset = 3;
  if (has_front_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->front_offset(), output);
  }

  // optional double front_radius = 4;
  if (has_front_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->front_radius(), output);
  }

  // optional double rear_offset = 5;
  if (has_rear_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->rear_offset(), output);
  }

  // optional double rear_radius = 6;
  if (has_rear_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->rear_radius(), output);
  }

  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  for (unsigned int i = 0, n = this->robot_vertices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->robot_vertices(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.FootprintModel)
}

::google::protobuf::uint8* FootprintModel::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.FootprintModel)
  // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional double radius = 2;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->radius(), target);
  }

  // optional double front_offset = 3;
  if (has_front_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->front_offset(), target);
  }

  // optional double front_radius = 4;
  if (has_front_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->front_radius(), target);
  }

  // optional double rear_offset = 5;
  if (has_rear_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->rear_offset(), target);
  }

  // optional double rear_radius = 6;
  if (has_rear_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->rear_radius(), target);
  }

  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  for (unsigned int i = 0, n = this->robot_vertices_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->robot_vertices(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.FootprintModel)
  return target;
}

int FootprintModel::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.FootprintModel)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional double radius = 2;
    if (has_radius()) {
      total_size += 1 + 8;
    }

    // optional double front_offset = 3;
    if (has_front_offset()) {
      total_size += 1 + 8;
    }

    // optional double front_radius = 4;
    if (has_front_radius()) {
      total_size += 1 + 8;
    }

    // optional double rear_offset = 5;
    if (has_rear_offset()) {
      total_size += 1 + 8;
    }

    // optional double rear_radius = 6;
    if (has_rear_radius()) {
      total_size += 1 + 8;
    }

  }
  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  total_size += 1 * this->robot_vertices_size();
  for (int i = 0; i < this->robot_vertices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->robot_vertices(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FootprintModel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.FootprintModel)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FootprintModel* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FootprintModel>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.FootprintModel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.FootprintModel)
    MergeFrom(*source);
  }
}

void FootprintModel::MergeFrom(const FootprintModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.FootprintModel)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  robot_vertices_.MergeFrom(from.robot_vertices_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_front_offset()) {
      set_front_offset(from.front_offset());
    }
    if (from.has_front_radius()) {
      set_front_radius(from.front_radius());
    }
    if (from.has_rear_offset()) {
      set_rear_offset(from.rear_offset());
    }
    if (from.has_rear_radius()) {
      set_rear_radius(from.rear_radius());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FootprintModel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.FootprintModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FootprintModel::CopyFrom(const FootprintModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.FootprintModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FootprintModel::IsInitialized() const {

  return true;
}

void FootprintModel::Swap(FootprintModel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FootprintModel::InternalSwap(FootprintModel* other) {
  std::swap(type_, other->type_);
  std::swap(radius_, other->radius_);
  std::swap(front_offset_, other->front_offset_);
  std::swap(front_radius_, other->front_radius_);
  std::swap(rear_offset_, other->rear_offset_);
  std::swap(rear_radius_, other->rear_radius_);
  robot_vertices_.UnsafeArenaSwap(&other->robot_vertices_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FootprintModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FootprintModel_descriptor_;
  metadata.reflection = FootprintModel_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FootprintModel

// optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
bool FootprintModel::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FootprintModel::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void FootprintModel::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void FootprintModel::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::roborts_local_planner::FootprintModel_FootprintType FootprintModel::type() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.type)
  return static_cast< ::roborts_local_planner::FootprintModel_FootprintType >(type_);
}
 void FootprintModel::set_type(::roborts_local_planner::FootprintModel_FootprintType value) {
  assert(::roborts_local_planner::FootprintModel_FootprintType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.type)
}

// optional double radius = 2;
bool FootprintModel::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FootprintModel::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
void FootprintModel::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
void FootprintModel::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
 double FootprintModel::radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.radius)
  return radius_;
}
 void FootprintModel::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.radius)
}

// optional double front_offset = 3;
bool FootprintModel::has_front_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FootprintModel::set_has_front_offset() {
  _has_bits_[0] |= 0x00000004u;
}
void FootprintModel::clear_has_front_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
void FootprintModel::clear_front_offset() {
  front_offset_ = 0;
  clear_has_front_offset();
}
 double FootprintModel::front_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_offset)
  return front_offset_;
}
 void FootprintModel::set_front_offset(double value) {
  set_has_front_offset();
  front_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_offset)
}

// optional double front_radius = 4;
bool FootprintModel::has_front_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FootprintModel::set_has_front_radius() {
  _has_bits_[0] |= 0x00000008u;
}
void FootprintModel::clear_has_front_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
void FootprintModel::clear_front_radius() {
  front_radius_ = 0;
  clear_has_front_radius();
}
 double FootprintModel::front_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_radius)
  return front_radius_;
}
 void FootprintModel::set_front_radius(double value) {
  set_has_front_radius();
  front_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_radius)
}

// optional double rear_offset = 5;
bool FootprintModel::has_rear_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FootprintModel::set_has_rear_offset() {
  _has_bits_[0] |= 0x00000010u;
}
void FootprintModel::clear_has_rear_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
void FootprintModel::clear_rear_offset() {
  rear_offset_ = 0;
  clear_has_rear_offset();
}
 double FootprintModel::rear_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_offset)
  return rear_offset_;
}
 void FootprintModel::set_rear_offset(double value) {
  set_has_rear_offset();
  rear_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_offset)
}

// optional double rear_radius = 6;
bool FootprintModel::has_rear_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FootprintModel::set_has_rear_radius() {
  _has_bits_[0] |= 0x00000020u;
}
void FootprintModel::clear_has_rear_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
void FootprintModel::clear_rear_radius() {
  rear_radius_ = 0;
  clear_has_rear_radius();
}
 double FootprintModel::rear_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_radius)
  return rear_radius_;
}
 void FootprintModel::set_rear_radius(double value) {
  set_has_rear_radius();
  rear_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_radius)
}

// repeated .roborts_local_planner.Point2D robot_vertices = 7;
int FootprintModel::robot_vertices_size() const {
  return robot_vertices_.size();
}
void FootprintModel::clear_robot_vertices() {
  robot_vertices_.Clear();
}
const ::roborts_local_planner::Point2D& FootprintModel::robot_vertices(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Get(index);
}
::roborts_local_planner::Point2D* FootprintModel::mutable_robot_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Mutable(index);
}
::roborts_local_planner::Point2D* FootprintModel::add_robot_vertices() {
  // @@protoc_insertion_point(field_add:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Add();
}
::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >*
FootprintModel::mutable_robot_vertices() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.FootprintModel.robot_vertices)
  return &robot_vertices_;
}
const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >&
FootprintModel::robot_vertices() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Robot::kMaxVelXFieldNumber;
const int Robot::kMaxVelXBackwardsFieldNumber;
const int Robot::kMaxVelYFieldNumber;
const int Robot::kMaxVelThetaFieldNumber;
const int Robot::kAccLimXFieldNumber;
const int Robot::kAccLimYFieldNumber;
const int Robot::kAccLimThetaFieldNumber;
const int Robot::kMinTurningRadiusFieldNumber;
const int Robot::kWheelbaseFieldNumber;
const int Robot::kCmdAngleInsteadRotvelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Robot::Robot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Robot)
}

void Robot::InitAsDefaultInstance() {
}

Robot::Robot(const Robot& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Robot)
}

void Robot::SharedCtor() {
  _cached_size_ = 0;
  max_vel_x_ = 0;
  max_vel_x_backwards_ = 0;
  max_vel_y_ = 0;
  max_vel_theta_ = 0;
  acc_lim_x_ = 0;
  acc_lim_y_ = 0;
  acc_lim_theta_ = 0;
  min_turning_radius_ = 0;
  wheelbase_ = 0;
  cmd_angle_instead_rotvel_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Robot)
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Robot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Robot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Robot_descriptor_;
}

const Robot& Robot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Robot* Robot::default_instance_ = NULL;

Robot* Robot::New(::google::protobuf::Arena* arena) const {
  Robot* n = new Robot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Robot)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Robot, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Robot*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(max_vel_x_, min_turning_radius_);
  }
  ZR_(wheelbase_, cmd_angle_instead_rotvel_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Robot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float max_vel_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_vel_x_)));
          set_has_max_vel_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_max_vel_x_backwards;
        break;
      }

      // optional float max_vel_x_backwards = 2;
      case 2: {
        if (tag == 21) {
         parse_max_vel_x_backwards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_vel_x_backwards_)));
          set_has_max_vel_x_backwards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_max_vel_y;
        break;
      }

      // optional float max_vel_y = 3;
      case 3: {
        if (tag == 29) {
         parse_max_vel_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_vel_y_)));
          set_has_max_vel_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_max_vel_theta;
        break;
      }

      // optional float max_vel_theta = 4;
      case 4: {
        if (tag == 37) {
         parse_max_vel_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_vel_theta_)));
          set_has_max_vel_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_acc_lim_x;
        break;
      }

      // optional float acc_lim_x = 5;
      case 5: {
        if (tag == 45) {
         parse_acc_lim_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_lim_x_)));
          set_has_acc_lim_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_acc_lim_y;
        break;
      }

      // optional float acc_lim_y = 6;
      case 6: {
        if (tag == 53) {
         parse_acc_lim_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_lim_y_)));
          set_has_acc_lim_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_acc_lim_theta;
        break;
      }

      // optional float acc_lim_theta = 7;
      case 7: {
        if (tag == 61) {
         parse_acc_lim_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_lim_theta_)));
          set_has_acc_lim_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_min_turning_radius;
        break;
      }

      // optional float min_turning_radius = 8;
      case 8: {
        if (tag == 69) {
         parse_min_turning_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_turning_radius_)));
          set_has_min_turning_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_wheelbase;
        break;
      }

      // optional float wheelbase = 9;
      case 9: {
        if (tag == 77) {
         parse_wheelbase:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &wheelbase_)));
          set_has_wheelbase();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_cmd_angle_instead_rotvel;
        break;
      }

      // optional bool cmd_angle_instead_rotvel = 10;
      case 10: {
        if (tag == 80) {
         parse_cmd_angle_instead_rotvel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cmd_angle_instead_rotvel_)));
          set_has_cmd_angle_instead_rotvel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Robot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Robot)
  return false;
#undef DO_
}

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Robot)
  // optional float max_vel_x = 1;
  if (has_max_vel_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->max_vel_x(), output);
  }

  // optional float max_vel_x_backwards = 2;
  if (has_max_vel_x_backwards()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max_vel_x_backwards(), output);
  }

  // optional float max_vel_y = 3;
  if (has_max_vel_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->max_vel_y(), output);
  }

  // optional float max_vel_theta = 4;
  if (has_max_vel_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->max_vel_theta(), output);
  }

  // optional float acc_lim_x = 5;
  if (has_acc_lim_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->acc_lim_x(), output);
  }

  // optional float acc_lim_y = 6;
  if (has_acc_lim_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->acc_lim_y(), output);
  }

  // optional float acc_lim_theta = 7;
  if (has_acc_lim_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->acc_lim_theta(), output);
  }

  // optional float min_turning_radius = 8;
  if (has_min_turning_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->min_turning_radius(), output);
  }

  // optional float wheelbase = 9;
  if (has_wheelbase()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->wheelbase(), output);
  }

  // optional bool cmd_angle_instead_rotvel = 10;
  if (has_cmd_angle_instead_rotvel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->cmd_angle_instead_rotvel(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Robot)
}

::google::protobuf::uint8* Robot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Robot)
  // optional float max_vel_x = 1;
  if (has_max_vel_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->max_vel_x(), target);
  }

  // optional float max_vel_x_backwards = 2;
  if (has_max_vel_x_backwards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->max_vel_x_backwards(), target);
  }

  // optional float max_vel_y = 3;
  if (has_max_vel_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->max_vel_y(), target);
  }

  // optional float max_vel_theta = 4;
  if (has_max_vel_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->max_vel_theta(), target);
  }

  // optional float acc_lim_x = 5;
  if (has_acc_lim_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->acc_lim_x(), target);
  }

  // optional float acc_lim_y = 6;
  if (has_acc_lim_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->acc_lim_y(), target);
  }

  // optional float acc_lim_theta = 7;
  if (has_acc_lim_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->acc_lim_theta(), target);
  }

  // optional float min_turning_radius = 8;
  if (has_min_turning_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->min_turning_radius(), target);
  }

  // optional float wheelbase = 9;
  if (has_wheelbase()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->wheelbase(), target);
  }

  // optional bool cmd_angle_instead_rotvel = 10;
  if (has_cmd_angle_instead_rotvel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->cmd_angle_instead_rotvel(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Robot)
  return target;
}

int Robot::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Robot)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional float max_vel_x = 1;
    if (has_max_vel_x()) {
      total_size += 1 + 4;
    }

    // optional float max_vel_x_backwards = 2;
    if (has_max_vel_x_backwards()) {
      total_size += 1 + 4;
    }

    // optional float max_vel_y = 3;
    if (has_max_vel_y()) {
      total_size += 1 + 4;
    }

    // optional float max_vel_theta = 4;
    if (has_max_vel_theta()) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_x = 5;
    if (has_acc_lim_x()) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_y = 6;
    if (has_acc_lim_y()) {
      total_size += 1 + 4;
    }

    // optional float acc_lim_theta = 7;
    if (has_acc_lim_theta()) {
      total_size += 1 + 4;
    }

    // optional float min_turning_radius = 8;
    if (has_min_turning_radius()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional float wheelbase = 9;
    if (has_wheelbase()) {
      total_size += 1 + 4;
    }

    // optional bool cmd_angle_instead_rotvel = 10;
    if (has_cmd_angle_instead_rotvel()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Robot)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Robot* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Robot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Robot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Robot)
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Robot)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_vel_x()) {
      set_max_vel_x(from.max_vel_x());
    }
    if (from.has_max_vel_x_backwards()) {
      set_max_vel_x_backwards(from.max_vel_x_backwards());
    }
    if (from.has_max_vel_y()) {
      set_max_vel_y(from.max_vel_y());
    }
    if (from.has_max_vel_theta()) {
      set_max_vel_theta(from.max_vel_theta());
    }
    if (from.has_acc_lim_x()) {
      set_acc_lim_x(from.acc_lim_x());
    }
    if (from.has_acc_lim_y()) {
      set_acc_lim_y(from.acc_lim_y());
    }
    if (from.has_acc_lim_theta()) {
      set_acc_lim_theta(from.acc_lim_theta());
    }
    if (from.has_min_turning_radius()) {
      set_min_turning_radius(from.min_turning_radius());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_wheelbase()) {
      set_wheelbase(from.wheelbase());
    }
    if (from.has_cmd_angle_instead_rotvel()) {
      set_cmd_angle_instead_rotvel(from.cmd_angle_instead_rotvel());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {

  return true;
}

void Robot::Swap(Robot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Robot::InternalSwap(Robot* other) {
  std::swap(max_vel_x_, other->max_vel_x_);
  std::swap(max_vel_x_backwards_, other->max_vel_x_backwards_);
  std::swap(max_vel_y_, other->max_vel_y_);
  std::swap(max_vel_theta_, other->max_vel_theta_);
  std::swap(acc_lim_x_, other->acc_lim_x_);
  std::swap(acc_lim_y_, other->acc_lim_y_);
  std::swap(acc_lim_theta_, other->acc_lim_theta_);
  std::swap(min_turning_radius_, other->min_turning_radius_);
  std::swap(wheelbase_, other->wheelbase_);
  std::swap(cmd_angle_instead_rotvel_, other->cmd_angle_instead_rotvel_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Robot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Robot_descriptor_;
  metadata.reflection = Robot_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Robot

// optional float max_vel_x = 1;
bool Robot::has_max_vel_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Robot::set_has_max_vel_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Robot::clear_has_max_vel_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Robot::clear_max_vel_x() {
  max_vel_x_ = 0;
  clear_has_max_vel_x();
}
 float Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x)
  return max_vel_x_;
}
 void Robot::set_max_vel_x(float value) {
  set_has_max_vel_x();
  max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x)
}

// optional float max_vel_x_backwards = 2;
bool Robot::has_max_vel_x_backwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Robot::set_has_max_vel_x_backwards() {
  _has_bits_[0] |= 0x00000002u;
}
void Robot::clear_has_max_vel_x_backwards() {
  _has_bits_[0] &= ~0x00000002u;
}
void Robot::clear_max_vel_x_backwards() {
  max_vel_x_backwards_ = 0;
  clear_has_max_vel_x_backwards();
}
 float Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x_backwards)
  return max_vel_x_backwards_;
}
 void Robot::set_max_vel_x_backwards(float value) {
  set_has_max_vel_x_backwards();
  max_vel_x_backwards_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x_backwards)
}

// optional float max_vel_y = 3;
bool Robot::has_max_vel_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Robot::set_has_max_vel_y() {
  _has_bits_[0] |= 0x00000004u;
}
void Robot::clear_has_max_vel_y() {
  _has_bits_[0] &= ~0x00000004u;
}
void Robot::clear_max_vel_y() {
  max_vel_y_ = 0;
  clear_has_max_vel_y();
}
 float Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_y)
  return max_vel_y_;
}
 void Robot::set_max_vel_y(float value) {
  set_has_max_vel_y();
  max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_y)
}

// optional float max_vel_theta = 4;
bool Robot::has_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Robot::set_has_max_vel_theta() {
  _has_bits_[0] |= 0x00000008u;
}
void Robot::clear_has_max_vel_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
void Robot::clear_max_vel_theta() {
  max_vel_theta_ = 0;
  clear_has_max_vel_theta();
}
 float Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_theta)
  return max_vel_theta_;
}
 void Robot::set_max_vel_theta(float value) {
  set_has_max_vel_theta();
  max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_theta)
}

// optional float acc_lim_x = 5;
bool Robot::has_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Robot::set_has_acc_lim_x() {
  _has_bits_[0] |= 0x00000010u;
}
void Robot::clear_has_acc_lim_x() {
  _has_bits_[0] &= ~0x00000010u;
}
void Robot::clear_acc_lim_x() {
  acc_lim_x_ = 0;
  clear_has_acc_lim_x();
}
 float Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_x)
  return acc_lim_x_;
}
 void Robot::set_acc_lim_x(float value) {
  set_has_acc_lim_x();
  acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_x)
}

// optional float acc_lim_y = 6;
bool Robot::has_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Robot::set_has_acc_lim_y() {
  _has_bits_[0] |= 0x00000020u;
}
void Robot::clear_has_acc_lim_y() {
  _has_bits_[0] &= ~0x00000020u;
}
void Robot::clear_acc_lim_y() {
  acc_lim_y_ = 0;
  clear_has_acc_lim_y();
}
 float Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_y)
  return acc_lim_y_;
}
 void Robot::set_acc_lim_y(float value) {
  set_has_acc_lim_y();
  acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_y)
}

// optional float acc_lim_theta = 7;
bool Robot::has_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Robot::set_has_acc_lim_theta() {
  _has_bits_[0] |= 0x00000040u;
}
void Robot::clear_has_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
void Robot::clear_acc_lim_theta() {
  acc_lim_theta_ = 0;
  clear_has_acc_lim_theta();
}
 float Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_theta)
  return acc_lim_theta_;
}
 void Robot::set_acc_lim_theta(float value) {
  set_has_acc_lim_theta();
  acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_theta)
}

// optional float min_turning_radius = 8;
bool Robot::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Robot::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000080u;
}
void Robot::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
void Robot::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
 float Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.min_turning_radius)
  return min_turning_radius_;
}
 void Robot::set_min_turning_radius(float value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.min_turning_radius)
}

// optional float wheelbase = 9;
bool Robot::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Robot::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000100u;
}
void Robot::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000100u;
}
void Robot::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
 float Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.wheelbase)
  return wheelbase_;
}
 void Robot::set_wheelbase(float value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
bool Robot::has_cmd_angle_instead_rotvel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Robot::set_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] |= 0x00000200u;
}
void Robot::clear_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] &= ~0x00000200u;
}
void Robot::clear_cmd_angle_instead_rotvel() {
  cmd_angle_instead_rotvel_ = false;
  clear_has_cmd_angle_instead_rotvel();
}
 bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
  return cmd_angle_instead_rotvel_;
}
 void Robot::set_cmd_angle_instead_rotvel(bool value) {
  set_has_cmd_angle_instead_rotvel();
  cmd_angle_instead_rotvel_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GoalTolerance::kXyGoalToleranceFieldNumber;
const int GoalTolerance::kYawGoalToleranceFieldNumber;
const int GoalTolerance::kFreeGoalVelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GoalTolerance::GoalTolerance()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.GoalTolerance)
}

void GoalTolerance::InitAsDefaultInstance() {
}

GoalTolerance::GoalTolerance(const GoalTolerance& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.GoalTolerance)
}

void GoalTolerance::SharedCtor() {
  _cached_size_ = 0;
  xy_goal_tolerance_ = 0;
  yaw_goal_tolerance_ = 0;
  free_goal_vel_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GoalTolerance::~GoalTolerance() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.GoalTolerance)
  SharedDtor();
}

void GoalTolerance::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GoalTolerance::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GoalTolerance::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GoalTolerance_descriptor_;
}

const GoalTolerance& GoalTolerance::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

GoalTolerance* GoalTolerance::default_instance_ = NULL;

GoalTolerance* GoalTolerance::New(::google::protobuf::Arena* arena) const {
  GoalTolerance* n = new GoalTolerance;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GoalTolerance::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.GoalTolerance)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(GoalTolerance, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<GoalTolerance*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(xy_goal_tolerance_, free_goal_vel_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GoalTolerance::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.GoalTolerance)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float xy_goal_tolerance = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &xy_goal_tolerance_)));
          set_has_xy_goal_tolerance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_yaw_goal_tolerance;
        break;
      }

      // optional float yaw_goal_tolerance = 2;
      case 2: {
        if (tag == 21) {
         parse_yaw_goal_tolerance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_goal_tolerance_)));
          set_has_yaw_goal_tolerance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_free_goal_vel;
        break;
      }

      // optional bool free_goal_vel = 3;
      case 3: {
        if (tag == 24) {
         parse_free_goal_vel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &free_goal_vel_)));
          set_has_free_goal_vel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.GoalTolerance)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.GoalTolerance)
  return false;
#undef DO_
}

void GoalTolerance::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.GoalTolerance)
  // optional float xy_goal_tolerance = 1;
  if (has_xy_goal_tolerance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->xy_goal_tolerance(), output);
  }

  // optional float yaw_goal_tolerance = 2;
  if (has_yaw_goal_tolerance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->yaw_goal_tolerance(), output);
  }

  // optional bool free_goal_vel = 3;
  if (has_free_goal_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->free_goal_vel(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.GoalTolerance)
}

::google::protobuf::uint8* GoalTolerance::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.GoalTolerance)
  // optional float xy_goal_tolerance = 1;
  if (has_xy_goal_tolerance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->xy_goal_tolerance(), target);
  }

  // optional float yaw_goal_tolerance = 2;
  if (has_yaw_goal_tolerance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->yaw_goal_tolerance(), target);
  }

  // optional bool free_goal_vel = 3;
  if (has_free_goal_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->free_goal_vel(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.GoalTolerance)
  return target;
}

int GoalTolerance::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.GoalTolerance)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional float xy_goal_tolerance = 1;
    if (has_xy_goal_tolerance()) {
      total_size += 1 + 4;
    }

    // optional float yaw_goal_tolerance = 2;
    if (has_yaw_goal_tolerance()) {
      total_size += 1 + 4;
    }

    // optional bool free_goal_vel = 3;
    if (has_free_goal_vel()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GoalTolerance::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.GoalTolerance)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GoalTolerance* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GoalTolerance>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.GoalTolerance)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.GoalTolerance)
    MergeFrom(*source);
  }
}

void GoalTolerance::MergeFrom(const GoalTolerance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.GoalTolerance)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xy_goal_tolerance()) {
      set_xy_goal_tolerance(from.xy_goal_tolerance());
    }
    if (from.has_yaw_goal_tolerance()) {
      set_yaw_goal_tolerance(from.yaw_goal_tolerance());
    }
    if (from.has_free_goal_vel()) {
      set_free_goal_vel(from.free_goal_vel());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GoalTolerance::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.GoalTolerance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GoalTolerance::CopyFrom(const GoalTolerance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.GoalTolerance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GoalTolerance::IsInitialized() const {

  return true;
}

void GoalTolerance::Swap(GoalTolerance* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GoalTolerance::InternalSwap(GoalTolerance* other) {
  std::swap(xy_goal_tolerance_, other->xy_goal_tolerance_);
  std::swap(yaw_goal_tolerance_, other->yaw_goal_tolerance_);
  std::swap(free_goal_vel_, other->free_goal_vel_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GoalTolerance::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GoalTolerance_descriptor_;
  metadata.reflection = GoalTolerance_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GoalTolerance

// optional float xy_goal_tolerance = 1;
bool GoalTolerance::has_xy_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GoalTolerance::set_has_xy_goal_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
void GoalTolerance::clear_has_xy_goal_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
void GoalTolerance::clear_xy_goal_tolerance() {
  xy_goal_tolerance_ = 0;
  clear_has_xy_goal_tolerance();
}
 float GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
  return xy_goal_tolerance_;
}
 void GoalTolerance::set_xy_goal_tolerance(float value) {
  set_has_xy_goal_tolerance();
  xy_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
}

// optional float yaw_goal_tolerance = 2;
bool GoalTolerance::has_yaw_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GoalTolerance::set_has_yaw_goal_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
void GoalTolerance::clear_has_yaw_goal_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
void GoalTolerance::clear_yaw_goal_tolerance() {
  yaw_goal_tolerance_ = 0;
  clear_has_yaw_goal_tolerance();
}
 float GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
  return yaw_goal_tolerance_;
}
 void GoalTolerance::set_yaw_goal_tolerance(float value) {
  set_has_yaw_goal_tolerance();
  yaw_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
}

// optional bool free_goal_vel = 3;
bool GoalTolerance::has_free_goal_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GoalTolerance::set_has_free_goal_vel() {
  _has_bits_[0] |= 0x00000004u;
}
void GoalTolerance::clear_has_free_goal_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
void GoalTolerance::clear_free_goal_vel() {
  free_goal_vel_ = false;
  clear_has_free_goal_vel();
}
 bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.free_goal_vel)
  return free_goal_vel_;
}
 void GoalTolerance::set_free_goal_vel(bool value) {
  set_has_free_goal_vel();
  free_goal_vel_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.free_goal_vel)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacles::kMinObstacleDistFieldNumber;
const int Obstacles::kInflationDistFieldNumber;
const int Obstacles::kIncludeCostmapObstaclesFieldNumber;
const int Obstacles::kCostmapObstaclesBehindRobotDistFieldNumber;
const int Obstacles::kObstaclePosesAffectedFieldNumber;
const int Obstacles::kLegacyObstacleAssociationFieldNumber;
const int Obstacles::kObstacleAssociationCutoffFactorFieldNumber;
const int Obstacles::kObstacleAssociationForceInclusionFactorFieldNumber;
const int Obstacles::kCostmapConverterPluginFieldNumber;
const int Obstacles::kCostmapConverterSpinThreadFieldNumber;
const int Obstacles::kCostmapConverterRateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacles::Obstacles()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Obstacles)
}

void Obstacles::InitAsDefaultInstance() {
}

Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Obstacles)
}

void Obstacles::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  min_obstacle_dist_ = 0;
  inflation_dist_ = 0;
  include_costmap_obstacles_ = false;
  costmap_obstacles_behind_robot_dist_ = 0;
  obstacle_poses_affected_ = 0;
  legacy_obstacle_association_ = false;
  obstacle_association_cutoff_factor_ = 0;
  obstacle_association_force_inclusion_factor_ = 0;
  costmap_converter_plugin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  costmap_converter_spin_thread_ = false;
  costmap_converter_rate_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
  costmap_converter_plugin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Obstacles::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacles::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Obstacles_descriptor_;
}

const Obstacles& Obstacles::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Obstacles* Obstacles::default_instance_ = NULL;

Obstacles* Obstacles::New(::google::protobuf::Arena* arena) const {
  Obstacles* n = new Obstacles;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Obstacles)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Obstacles, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Obstacles*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(min_obstacle_dist_, legacy_obstacle_association_);
    obstacle_association_cutoff_factor_ = 0;
    obstacle_association_force_inclusion_factor_ = 0;
  }
  if (_has_bits_[8 / 32] & 1792u) {
    if (has_costmap_converter_plugin()) {
      costmap_converter_plugin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    costmap_converter_spin_thread_ = false;
    costmap_converter_rate_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Obstacles)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float min_obstacle_dist = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_obstacle_dist_)));
          set_has_min_obstacle_dist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_inflation_dist;
        break;
      }

      // optional float inflation_dist = 2;
      case 2: {
        if (tag == 21) {
         parse_inflation_dist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inflation_dist_)));
          set_has_inflation_dist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_include_costmap_obstacles;
        break;
      }

      // optional bool include_costmap_obstacles = 3;
      case 3: {
        if (tag == 24) {
         parse_include_costmap_obstacles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_costmap_obstacles_)));
          set_has_include_costmap_obstacles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_costmap_obstacles_behind_robot_dist;
        break;
      }

      // optional float costmap_obstacles_behind_robot_dist = 4;
      case 4: {
        if (tag == 37) {
         parse_costmap_obstacles_behind_robot_dist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &costmap_obstacles_behind_robot_dist_)));
          set_has_costmap_obstacles_behind_robot_dist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_obstacle_poses_affected;
        break;
      }

      // optional float obstacle_poses_affected = 5;
      case 5: {
        if (tag == 45) {
         parse_obstacle_poses_affected:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obstacle_poses_affected_)));
          set_has_obstacle_poses_affected();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_legacy_obstacle_association;
        break;
      }

      // optional bool legacy_obstacle_association = 6;
      case 6: {
        if (tag == 48) {
         parse_legacy_obstacle_association:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &legacy_obstacle_association_)));
          set_has_legacy_obstacle_association();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_obstacle_association_cutoff_factor;
        break;
      }

      // optional float obstacle_association_cutoff_factor = 7;
      case 7: {
        if (tag == 61) {
         parse_obstacle_association_cutoff_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obstacle_association_cutoff_factor_)));
          set_has_obstacle_association_cutoff_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_obstacle_association_force_inclusion_factor;
        break;
      }

      // optional float obstacle_association_force_inclusion_factor = 8;
      case 8: {
        if (tag == 69) {
         parse_obstacle_association_force_inclusion_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obstacle_association_force_inclusion_factor_)));
          set_has_obstacle_association_force_inclusion_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_costmap_converter_plugin;
        break;
      }

      // optional string costmap_converter_plugin = 9;
      case 9: {
        if (tag == 74) {
         parse_costmap_converter_plugin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_costmap_converter_plugin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->costmap_converter_plugin().data(), this->costmap_converter_plugin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roborts_local_planner.Obstacles.costmap_converter_plugin");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_costmap_converter_spin_thread;
        break;
      }

      // optional bool costmap_converter_spin_thread = 10;
      case 10: {
        if (tag == 80) {
         parse_costmap_converter_spin_thread:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &costmap_converter_spin_thread_)));
          set_has_costmap_converter_spin_thread();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_costmap_converter_rate;
        break;
      }

      // optional float costmap_converter_rate = 11;
      case 11: {
        if (tag == 93) {
         parse_costmap_converter_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &costmap_converter_rate_)));
          set_has_costmap_converter_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Obstacles)
  return false;
#undef DO_
}

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Obstacles)
  // optional float min_obstacle_dist = 1;
  if (has_min_obstacle_dist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->min_obstacle_dist(), output);
  }

  // optional float inflation_dist = 2;
  if (has_inflation_dist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->inflation_dist(), output);
  }

  // optional bool include_costmap_obstacles = 3;
  if (has_include_costmap_obstacles()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->include_costmap_obstacles(), output);
  }

  // optional float costmap_obstacles_behind_robot_dist = 4;
  if (has_costmap_obstacles_behind_robot_dist()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->costmap_obstacles_behind_robot_dist(), output);
  }

  // optional float obstacle_poses_affected = 5;
  if (has_obstacle_poses_affected()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->obstacle_poses_affected(), output);
  }

  // optional bool legacy_obstacle_association = 6;
  if (has_legacy_obstacle_association()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->legacy_obstacle_association(), output);
  }

  // optional float obstacle_association_cutoff_factor = 7;
  if (has_obstacle_association_cutoff_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->obstacle_association_cutoff_factor(), output);
  }

  // optional float obstacle_association_force_inclusion_factor = 8;
  if (has_obstacle_association_force_inclusion_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->obstacle_association_force_inclusion_factor(), output);
  }

  // optional string costmap_converter_plugin = 9;
  if (has_costmap_converter_plugin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->costmap_converter_plugin().data(), this->costmap_converter_plugin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.Obstacles.costmap_converter_plugin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->costmap_converter_plugin(), output);
  }

  // optional bool costmap_converter_spin_thread = 10;
  if (has_costmap_converter_spin_thread()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->costmap_converter_spin_thread(), output);
  }

  // optional float costmap_converter_rate = 11;
  if (has_costmap_converter_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->costmap_converter_rate(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Obstacles)
}

::google::protobuf::uint8* Obstacles::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Obstacles)
  // optional float min_obstacle_dist = 1;
  if (has_min_obstacle_dist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->min_obstacle_dist(), target);
  }

  // optional float inflation_dist = 2;
  if (has_inflation_dist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->inflation_dist(), target);
  }

  // optional bool include_costmap_obstacles = 3;
  if (has_include_costmap_obstacles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->include_costmap_obstacles(), target);
  }

  // optional float costmap_obstacles_behind_robot_dist = 4;
  if (has_costmap_obstacles_behind_robot_dist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->costmap_obstacles_behind_robot_dist(), target);
  }

  // optional float obstacle_poses_affected = 5;
  if (has_obstacle_poses_affected()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->obstacle_poses_affected(), target);
  }

  // optional bool legacy_obstacle_association = 6;
  if (has_legacy_obstacle_association()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->legacy_obstacle_association(), target);
  }

  // optional float obstacle_association_cutoff_factor = 7;
  if (has_obstacle_association_cutoff_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->obstacle_association_cutoff_factor(), target);
  }

  // optional float obstacle_association_force_inclusion_factor = 8;
  if (has_obstacle_association_force_inclusion_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->obstacle_association_force_inclusion_factor(), target);
  }

  // optional string costmap_converter_plugin = 9;
  if (has_costmap_converter_plugin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->costmap_converter_plugin().data(), this->costmap_converter_plugin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roborts_local_planner.Obstacles.costmap_converter_plugin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->costmap_converter_plugin(), target);
  }

  // optional bool costmap_converter_spin_thread = 10;
  if (has_costmap_converter_spin_thread()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->costmap_converter_spin_thread(), target);
  }

  // optional float costmap_converter_rate = 11;
  if (has_costmap_converter_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->costmap_converter_rate(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Obstacles)
  return target;
}

int Obstacles::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Obstacles)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional float min_obstacle_dist = 1;
    if (has_min_obstacle_dist()) {
      total_size += 1 + 4;
    }

    // optional float inflation_dist = 2;
    if (has_inflation_dist()) {
      total_size += 1 + 4;
    }

    // optional bool include_costmap_obstacles = 3;
    if (has_include_costmap_obstacles()) {
      total_size += 1 + 1;
    }

    // optional float costmap_obstacles_behind_robot_dist = 4;
    if (has_costmap_obstacles_behind_robot_dist()) {
      total_size += 1 + 4;
    }

    // optional float obstacle_poses_affected = 5;
    if (has_obstacle_poses_affected()) {
      total_size += 1 + 4;
    }

    // optional bool legacy_obstacle_association = 6;
    if (has_legacy_obstacle_association()) {
      total_size += 1 + 1;
    }

    // optional float obstacle_association_cutoff_factor = 7;
    if (has_obstacle_association_cutoff_factor()) {
      total_size += 1 + 4;
    }

    // optional float obstacle_association_force_inclusion_factor = 8;
    if (has_obstacle_association_force_inclusion_factor()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional string costmap_converter_plugin = 9;
    if (has_costmap_converter_plugin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->costmap_converter_plugin());
    }

    // optional bool costmap_converter_spin_thread = 10;
    if (has_costmap_converter_spin_thread()) {
      total_size += 1 + 1;
    }

    // optional float costmap_converter_rate = 11;
    if (has_costmap_converter_rate()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Obstacles)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Obstacles* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Obstacles>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Obstacles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Obstacles)
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Obstacles)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min_obstacle_dist()) {
      set_min_obstacle_dist(from.min_obstacle_dist());
    }
    if (from.has_inflation_dist()) {
      set_inflation_dist(from.inflation_dist());
    }
    if (from.has_include_costmap_obstacles()) {
      set_include_costmap_obstacles(from.include_costmap_obstacles());
    }
    if (from.has_costmap_obstacles_behind_robot_dist()) {
      set_costmap_obstacles_behind_robot_dist(from.costmap_obstacles_behind_robot_dist());
    }
    if (from.has_obstacle_poses_affected()) {
      set_obstacle_poses_affected(from.obstacle_poses_affected());
    }
    if (from.has_legacy_obstacle_association()) {
      set_legacy_obstacle_association(from.legacy_obstacle_association());
    }
    if (from.has_obstacle_association_cutoff_factor()) {
      set_obstacle_association_cutoff_factor(from.obstacle_association_cutoff_factor());
    }
    if (from.has_obstacle_association_force_inclusion_factor()) {
      set_obstacle_association_force_inclusion_factor(from.obstacle_association_force_inclusion_factor());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_costmap_converter_plugin()) {
      set_has_costmap_converter_plugin();
      costmap_converter_plugin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.costmap_converter_plugin_);
    }
    if (from.has_costmap_converter_spin_thread()) {
      set_costmap_converter_spin_thread(from.costmap_converter_spin_thread());
    }
    if (from.has_costmap_converter_rate()) {
      set_costmap_converter_rate(from.costmap_converter_rate());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {

  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacles::InternalSwap(Obstacles* other) {
  std::swap(min_obstacle_dist_, other->min_obstacle_dist_);
  std::swap(inflation_dist_, other->inflation_dist_);
  std::swap(include_costmap_obstacles_, other->include_costmap_obstacles_);
  std::swap(costmap_obstacles_behind_robot_dist_, other->costmap_obstacles_behind_robot_dist_);
  std::swap(obstacle_poses_affected_, other->obstacle_poses_affected_);
  std::swap(legacy_obstacle_association_, other->legacy_obstacle_association_);
  std::swap(obstacle_association_cutoff_factor_, other->obstacle_association_cutoff_factor_);
  std::swap(obstacle_association_force_inclusion_factor_, other->obstacle_association_force_inclusion_factor_);
  costmap_converter_plugin_.Swap(&other->costmap_converter_plugin_);
  std::swap(costmap_converter_spin_thread_, other->costmap_converter_spin_thread_);
  std::swap(costmap_converter_rate_, other->costmap_converter_rate_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Obstacles_descriptor_;
  metadata.reflection = Obstacles_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Obstacles

// optional float min_obstacle_dist = 1;
bool Obstacles::has_min_obstacle_dist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Obstacles::set_has_min_obstacle_dist() {
  _has_bits_[0] |= 0x00000001u;
}
void Obstacles::clear_has_min_obstacle_dist() {
  _has_bits_[0] &= ~0x00000001u;
}
void Obstacles::clear_min_obstacle_dist() {
  min_obstacle_dist_ = 0;
  clear_has_min_obstacle_dist();
}
 float Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.min_obstacle_dist)
  return min_obstacle_dist_;
}
 void Obstacles::set_min_obstacle_dist(float value) {
  set_has_min_obstacle_dist();
  min_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.min_obstacle_dist)
}

// optional float inflation_dist = 2;
bool Obstacles::has_inflation_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Obstacles::set_has_inflation_dist() {
  _has_bits_[0] |= 0x00000002u;
}
void Obstacles::clear_has_inflation_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
void Obstacles::clear_inflation_dist() {
  inflation_dist_ = 0;
  clear_has_inflation_dist();
}
 float Obstacles::inflation_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.inflation_dist)
  return inflation_dist_;
}
 void Obstacles::set_inflation_dist(float value) {
  set_has_inflation_dist();
  inflation_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.inflation_dist)
}

// optional bool include_costmap_obstacles = 3;
bool Obstacles::has_include_costmap_obstacles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Obstacles::set_has_include_costmap_obstacles() {
  _has_bits_[0] |= 0x00000004u;
}
void Obstacles::clear_has_include_costmap_obstacles() {
  _has_bits_[0] &= ~0x00000004u;
}
void Obstacles::clear_include_costmap_obstacles() {
  include_costmap_obstacles_ = false;
  clear_has_include_costmap_obstacles();
}
 bool Obstacles::include_costmap_obstacles() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.include_costmap_obstacles)
  return include_costmap_obstacles_;
}
 void Obstacles::set_include_costmap_obstacles(bool value) {
  set_has_include_costmap_obstacles();
  include_costmap_obstacles_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.include_costmap_obstacles)
}

// optional float costmap_obstacles_behind_robot_dist = 4;
bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Obstacles::set_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] |= 0x00000008u;
}
void Obstacles::clear_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  costmap_obstacles_behind_robot_dist_ = 0;
  clear_has_costmap_obstacles_behind_robot_dist();
}
 float Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
  return costmap_obstacles_behind_robot_dist_;
}
 void Obstacles::set_costmap_obstacles_behind_robot_dist(float value) {
  set_has_costmap_obstacles_behind_robot_dist();
  costmap_obstacles_behind_robot_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional float obstacle_poses_affected = 5;
bool Obstacles::has_obstacle_poses_affected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Obstacles::set_has_obstacle_poses_affected() {
  _has_bits_[0] |= 0x00000010u;
}
void Obstacles::clear_has_obstacle_poses_affected() {
  _has_bits_[0] &= ~0x00000010u;
}
void Obstacles::clear_obstacle_poses_affected() {
  obstacle_poses_affected_ = 0;
  clear_has_obstacle_poses_affected();
}
 float Obstacles::obstacle_poses_affected() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_poses_affected)
  return obstacle_poses_affected_;
}
 void Obstacles::set_obstacle_poses_affected(float value) {
  set_has_obstacle_poses_affected();
  obstacle_poses_affected_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_poses_affected)
}

// optional bool legacy_obstacle_association = 6;
bool Obstacles::has_legacy_obstacle_association() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Obstacles::set_has_legacy_obstacle_association() {
  _has_bits_[0] |= 0x00000020u;
}
void Obstacles::clear_has_legacy_obstacle_association() {
  _has_bits_[0] &= ~0x00000020u;
}
void Obstacles::clear_legacy_obstacle_association() {
  legacy_obstacle_association_ = false;
  clear_has_legacy_obstacle_association();
}
 bool Obstacles::legacy_obstacle_association() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.legacy_obstacle_association)
  return legacy_obstacle_association_;
}
 void Obstacles::set_legacy_obstacle_association(bool value) {
  set_has_legacy_obstacle_association();
  legacy_obstacle_association_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.legacy_obstacle_association)
}

// optional float obstacle_association_cutoff_factor = 7;
bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Obstacles::set_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] |= 0x00000040u;
}
void Obstacles::clear_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] &= ~0x00000040u;
}
void Obstacles::clear_obstacle_association_cutoff_factor() {
  obstacle_association_cutoff_factor_ = 0;
  clear_has_obstacle_association_cutoff_factor();
}
 float Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
  return obstacle_association_cutoff_factor_;
}
 void Obstacles::set_obstacle_association_cutoff_factor(float value) {
  set_has_obstacle_association_cutoff_factor();
  obstacle_association_cutoff_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
}

// optional float obstacle_association_force_inclusion_factor = 8;
bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Obstacles::set_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] |= 0x00000080u;
}
void Obstacles::clear_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] &= ~0x00000080u;
}
void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  obstacle_association_force_inclusion_factor_ = 0;
  clear_has_obstacle_association_force_inclusion_factor();
}
 float Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
  return obstacle_association_force_inclusion_factor_;
}
 void Obstacles::set_obstacle_association_force_inclusion_factor(float value) {
  set_has_obstacle_association_force_inclusion_factor();
  obstacle_association_force_inclusion_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
}

// optional string costmap_converter_plugin = 9;
bool Obstacles::has_costmap_converter_plugin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Obstacles::set_has_costmap_converter_plugin() {
  _has_bits_[0] |= 0x00000100u;
}
void Obstacles::clear_has_costmap_converter_plugin() {
  _has_bits_[0] &= ~0x00000100u;
}
void Obstacles::clear_costmap_converter_plugin() {
  costmap_converter_plugin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_costmap_converter_plugin();
}
 const ::std::string& Obstacles::costmap_converter_plugin() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return costmap_converter_plugin_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Obstacles::set_costmap_converter_plugin(const ::std::string& value) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
 void Obstacles::set_costmap_converter_plugin(const char* value) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
 void Obstacles::set_costmap_converter_plugin(const char* value, size_t size) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
 ::std::string* Obstacles::mutable_costmap_converter_plugin() {
  set_has_costmap_converter_plugin();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return costmap_converter_plugin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Obstacles::release_costmap_converter_plugin() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Obstacles.costmap_converter_plugin)
  clear_has_costmap_converter_plugin();
  return costmap_converter_plugin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Obstacles::set_allocated_costmap_converter_plugin(::std::string* costmap_converter_plugin) {
  if (costmap_converter_plugin != NULL) {
    set_has_costmap_converter_plugin();
  } else {
    clear_has_costmap_converter_plugin();
  }
  costmap_converter_plugin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), costmap_converter_plugin);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Obstacles.costmap_converter_plugin)
}

// optional bool costmap_converter_spin_thread = 10;
bool Obstacles::has_costmap_converter_spin_thread() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Obstacles::set_has_costmap_converter_spin_thread() {
  _has_bits_[0] |= 0x00000200u;
}
void Obstacles::clear_has_costmap_converter_spin_thread() {
  _has_bits_[0] &= ~0x00000200u;
}
void Obstacles::clear_costmap_converter_spin_thread() {
  costmap_converter_spin_thread_ = false;
  clear_has_costmap_converter_spin_thread();
}
 bool Obstacles::costmap_converter_spin_thread() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
  return costmap_converter_spin_thread_;
}
 void Obstacles::set_costmap_converter_spin_thread(bool value) {
  set_has_costmap_converter_spin_thread();
  costmap_converter_spin_thread_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
}

// optional float costmap_converter_rate = 11;
bool Obstacles::has_costmap_converter_rate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Obstacles::set_has_costmap_converter_rate() {
  _has_bits_[0] |= 0x00000400u;
}
void Obstacles::clear_has_costmap_converter_rate() {
  _has_bits_[0] &= ~0x00000400u;
}
void Obstacles::clear_costmap_converter_rate() {
  costmap_converter_rate_ = 0;
  clear_has_costmap_converter_rate();
}
 float Obstacles::costmap_converter_rate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_rate)
  return costmap_converter_rate_;
}
 void Obstacles::set_costmap_converter_rate(float value) {
  set_has_costmap_converter_rate();
  costmap_converter_rate_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_rate)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Optimization::kNoInnerIterationsFieldNumber;
const int Optimization::kNoOuterIterationsFieldNumber;
const int Optimization::kOptimizationActivateFieldNumber;
const int Optimization::kOptimizationVerboseFieldNumber;
const int Optimization::kPenaltyEpsilonFieldNumber;
const int Optimization::kWeightMaxVelXFieldNumber;
const int Optimization::kWeightMaxVelYFieldNumber;
const int Optimization::kWeightMaxVelThetaFieldNumber;
const int Optimization::kWeightAccLimXFieldNumber;
const int Optimization::kWeightAccLimYFieldNumber;
const int Optimization::kWeightAccLimThetFieldNumber;
const int Optimization::kWeightKinematicsNhFieldNumber;
const int Optimization::kWeightKinematicsForwardDriveFieldNumber;
const int Optimization::kWeightKinematicsTurningRadiusFieldNumber;
const int Optimization::kWeightOptimaltimeFieldNumber;
const int Optimization::kWeightObstacleFieldNumber;
const int Optimization::kWeightInflationFieldNumber;
const int Optimization::kWeightDynamicObstacleFieldNumber;
const int Optimization::kWeightViapointFieldNumber;
const int Optimization::kWeightAdaptFactorFieldNumber;
const int Optimization::kWeightPreferRotdirFieldNumber;
const int Optimization::kWeightAccLimThetaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Optimization::Optimization()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Optimization)
}

void Optimization::InitAsDefaultInstance() {
}

Optimization::Optimization(const Optimization& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Optimization)
}

void Optimization::SharedCtor() {
  _cached_size_ = 0;
  no_inner_iterations_ = 0;
  no_outer_iterations_ = 0;
  optimization_activate_ = false;
  optimization_verbose_ = false;
  penalty_epsilon_ = 0;
  weight_max_vel_x_ = 0;
  weight_max_vel_y_ = 0;
  weight_max_vel_theta_ = 0;
  weight_acc_lim_x_ = 0;
  weight_acc_lim_y_ = 0;
  weight_acc_lim_thet_ = 0;
  weight_kinematics_nh_ = 0;
  weight_kinematics_forward_drive_ = 0;
  weight_kinematics_turning_radius_ = 0;
  weight_optimaltime_ = 0;
  weight_obstacle_ = 0;
  weight_inflation_ = 0;
  weight_dynamic_obstacle_ = 0;
  weight_viapoint_ = 0;
  weight_adapt_factor_ = 0;
  weight_prefer_rotdir_ = 0;
  weight_acc_lim_theta_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Optimization::~Optimization() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Optimization)
  SharedDtor();
}

void Optimization::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Optimization::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Optimization::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Optimization_descriptor_;
}

const Optimization& Optimization::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Optimization* Optimization::default_instance_ = NULL;

Optimization* Optimization::New(::google::protobuf::Arena* arena) const {
  Optimization* n = new Optimization;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Optimization::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Optimization)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Optimization, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Optimization*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(no_inner_iterations_, weight_max_vel_theta_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(weight_acc_lim_x_, weight_obstacle_);
  }
  if (_has_bits_[16 / 32] & 4128768u) {
    ZR_(weight_inflation_, weight_acc_lim_theta_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Optimization::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Optimization)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 no_inner_iterations = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &no_inner_iterations_)));
          set_has_no_inner_iterations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_no_outer_iterations;
        break;
      }

      // optional int32 no_outer_iterations = 2;
      case 2: {
        if (tag == 16) {
         parse_no_outer_iterations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &no_outer_iterations_)));
          set_has_no_outer_iterations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_optimization_activate;
        break;
      }

      // optional bool optimization_activate = 3;
      case 3: {
        if (tag == 24) {
         parse_optimization_activate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &optimization_activate_)));
          set_has_optimization_activate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_optimization_verbose;
        break;
      }

      // optional bool optimization_verbose = 4;
      case 4: {
        if (tag == 32) {
         parse_optimization_verbose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &optimization_verbose_)));
          set_has_optimization_verbose();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_penalty_epsilon;
        break;
      }

      // optional float penalty_epsilon = 5;
      case 5: {
        if (tag == 45) {
         parse_penalty_epsilon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &penalty_epsilon_)));
          set_has_penalty_epsilon();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_weight_max_vel_x;
        break;
      }

      // optional float weight_max_vel_x = 6;
      case 6: {
        if (tag == 53) {
         parse_weight_max_vel_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_max_vel_x_)));
          set_has_weight_max_vel_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_weight_max_vel_y;
        break;
      }

      // optional float weight_max_vel_y = 7;
      case 7: {
        if (tag == 61) {
         parse_weight_max_vel_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_max_vel_y_)));
          set_has_weight_max_vel_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_weight_max_vel_theta;
        break;
      }

      // optional float weight_max_vel_theta = 8;
      case 8: {
        if (tag == 69) {
         parse_weight_max_vel_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_max_vel_theta_)));
          set_has_weight_max_vel_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_weight_acc_lim_x;
        break;
      }

      // optional float weight_acc_lim_x = 9;
      case 9: {
        if (tag == 77) {
         parse_weight_acc_lim_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_acc_lim_x_)));
          set_has_weight_acc_lim_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_weight_acc_lim_y;
        break;
      }

      // optional float weight_acc_lim_y = 10;
      case 10: {
        if (tag == 85) {
         parse_weight_acc_lim_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_acc_lim_y_)));
          set_has_weight_acc_lim_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_weight_acc_lim_thet;
        break;
      }

      // optional float weight_acc_lim_thet = 11;
      case 11: {
        if (tag == 93) {
         parse_weight_acc_lim_thet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_acc_lim_thet_)));
          set_has_weight_acc_lim_thet();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_weight_kinematics_nh;
        break;
      }

      // optional float weight_kinematics_nh = 12;
      case 12: {
        if (tag == 101) {
         parse_weight_kinematics_nh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_kinematics_nh_)));
          set_has_weight_kinematics_nh();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(109)) goto parse_weight_kinematics_forward_drive;
        break;
      }

      // optional float weight_kinematics_forward_drive = 13;
      case 13: {
        if (tag == 109) {
         parse_weight_kinematics_forward_drive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_kinematics_forward_drive_)));
          set_has_weight_kinematics_forward_drive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(117)) goto parse_weight_kinematics_turning_radius;
        break;
      }

      // optional float weight_kinematics_turning_radius = 14;
      case 14: {
        if (tag == 117) {
         parse_weight_kinematics_turning_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_kinematics_turning_radius_)));
          set_has_weight_kinematics_turning_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(125)) goto parse_weight_optimaltime;
        break;
      }

      // optional float weight_optimaltime = 15;
      case 15: {
        if (tag == 125) {
         parse_weight_optimaltime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_optimaltime_)));
          set_has_weight_optimaltime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(133)) goto parse_weight_obstacle;
        break;
      }

      // optional float weight_obstacle = 16;
      case 16: {
        if (tag == 133) {
         parse_weight_obstacle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_obstacle_)));
          set_has_weight_obstacle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(141)) goto parse_weight_inflation;
        break;
      }

      // optional float weight_inflation = 17;
      case 17: {
        if (tag == 141) {
         parse_weight_inflation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_inflation_)));
          set_has_weight_inflation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(149)) goto parse_weight_dynamic_obstacle;
        break;
      }

      // optional float weight_dynamic_obstacle = 18;
      case 18: {
        if (tag == 149) {
         parse_weight_dynamic_obstacle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_dynamic_obstacle_)));
          set_has_weight_dynamic_obstacle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(157)) goto parse_weight_viapoint;
        break;
      }

      // optional float weight_viapoint = 19;
      case 19: {
        if (tag == 157) {
         parse_weight_viapoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_viapoint_)));
          set_has_weight_viapoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(165)) goto parse_weight_adapt_factor;
        break;
      }

      // optional float weight_adapt_factor = 20;
      case 20: {
        if (tag == 165) {
         parse_weight_adapt_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_adapt_factor_)));
          set_has_weight_adapt_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(173)) goto parse_weight_prefer_rotdir;
        break;
      }

      // optional float weight_prefer_rotdir = 21;
      case 21: {
        if (tag == 173) {
         parse_weight_prefer_rotdir:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_prefer_rotdir_)));
          set_has_weight_prefer_rotdir();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(181)) goto parse_weight_acc_lim_theta;
        break;
      }

      // optional float weight_acc_lim_theta = 22;
      case 22: {
        if (tag == 181) {
         parse_weight_acc_lim_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_acc_lim_theta_)));
          set_has_weight_acc_lim_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Optimization)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Optimization)
  return false;
#undef DO_
}

void Optimization::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Optimization)
  // optional int32 no_inner_iterations = 1;
  if (has_no_inner_iterations()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->no_inner_iterations(), output);
  }

  // optional int32 no_outer_iterations = 2;
  if (has_no_outer_iterations()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->no_outer_iterations(), output);
  }

  // optional bool optimization_activate = 3;
  if (has_optimization_activate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->optimization_activate(), output);
  }

  // optional bool optimization_verbose = 4;
  if (has_optimization_verbose()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->optimization_verbose(), output);
  }

  // optional float penalty_epsilon = 5;
  if (has_penalty_epsilon()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->penalty_epsilon(), output);
  }

  // optional float weight_max_vel_x = 6;
  if (has_weight_max_vel_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->weight_max_vel_x(), output);
  }

  // optional float weight_max_vel_y = 7;
  if (has_weight_max_vel_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->weight_max_vel_y(), output);
  }

  // optional float weight_max_vel_theta = 8;
  if (has_weight_max_vel_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->weight_max_vel_theta(), output);
  }

  // optional float weight_acc_lim_x = 9;
  if (has_weight_acc_lim_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->weight_acc_lim_x(), output);
  }

  // optional float weight_acc_lim_y = 10;
  if (has_weight_acc_lim_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->weight_acc_lim_y(), output);
  }

  // optional float weight_acc_lim_thet = 11;
  if (has_weight_acc_lim_thet()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->weight_acc_lim_thet(), output);
  }

  // optional float weight_kinematics_nh = 12;
  if (has_weight_kinematics_nh()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->weight_kinematics_nh(), output);
  }

  // optional float weight_kinematics_forward_drive = 13;
  if (has_weight_kinematics_forward_drive()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->weight_kinematics_forward_drive(), output);
  }

  // optional float weight_kinematics_turning_radius = 14;
  if (has_weight_kinematics_turning_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->weight_kinematics_turning_radius(), output);
  }

  // optional float weight_optimaltime = 15;
  if (has_weight_optimaltime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->weight_optimaltime(), output);
  }

  // optional float weight_obstacle = 16;
  if (has_weight_obstacle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->weight_obstacle(), output);
  }

  // optional float weight_inflation = 17;
  if (has_weight_inflation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->weight_inflation(), output);
  }

  // optional float weight_dynamic_obstacle = 18;
  if (has_weight_dynamic_obstacle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->weight_dynamic_obstacle(), output);
  }

  // optional float weight_viapoint = 19;
  if (has_weight_viapoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(19, this->weight_viapoint(), output);
  }

  // optional float weight_adapt_factor = 20;
  if (has_weight_adapt_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(20, this->weight_adapt_factor(), output);
  }

  // optional float weight_prefer_rotdir = 21;
  if (has_weight_prefer_rotdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->weight_prefer_rotdir(), output);
  }

  // optional float weight_acc_lim_theta = 22;
  if (has_weight_acc_lim_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(22, this->weight_acc_lim_theta(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Optimization)
}

::google::protobuf::uint8* Optimization::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Optimization)
  // optional int32 no_inner_iterations = 1;
  if (has_no_inner_iterations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->no_inner_iterations(), target);
  }

  // optional int32 no_outer_iterations = 2;
  if (has_no_outer_iterations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->no_outer_iterations(), target);
  }

  // optional bool optimization_activate = 3;
  if (has_optimization_activate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->optimization_activate(), target);
  }

  // optional bool optimization_verbose = 4;
  if (has_optimization_verbose()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->optimization_verbose(), target);
  }

  // optional float penalty_epsilon = 5;
  if (has_penalty_epsilon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->penalty_epsilon(), target);
  }

  // optional float weight_max_vel_x = 6;
  if (has_weight_max_vel_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->weight_max_vel_x(), target);
  }

  // optional float weight_max_vel_y = 7;
  if (has_weight_max_vel_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->weight_max_vel_y(), target);
  }

  // optional float weight_max_vel_theta = 8;
  if (has_weight_max_vel_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->weight_max_vel_theta(), target);
  }

  // optional float weight_acc_lim_x = 9;
  if (has_weight_acc_lim_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->weight_acc_lim_x(), target);
  }

  // optional float weight_acc_lim_y = 10;
  if (has_weight_acc_lim_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->weight_acc_lim_y(), target);
  }

  // optional float weight_acc_lim_thet = 11;
  if (has_weight_acc_lim_thet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->weight_acc_lim_thet(), target);
  }

  // optional float weight_kinematics_nh = 12;
  if (has_weight_kinematics_nh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->weight_kinematics_nh(), target);
  }

  // optional float weight_kinematics_forward_drive = 13;
  if (has_weight_kinematics_forward_drive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->weight_kinematics_forward_drive(), target);
  }

  // optional float weight_kinematics_turning_radius = 14;
  if (has_weight_kinematics_turning_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->weight_kinematics_turning_radius(), target);
  }

  // optional float weight_optimaltime = 15;
  if (has_weight_optimaltime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->weight_optimaltime(), target);
  }

  // optional float weight_obstacle = 16;
  if (has_weight_obstacle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->weight_obstacle(), target);
  }

  // optional float weight_inflation = 17;
  if (has_weight_inflation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->weight_inflation(), target);
  }

  // optional float weight_dynamic_obstacle = 18;
  if (has_weight_dynamic_obstacle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(18, this->weight_dynamic_obstacle(), target);
  }

  // optional float weight_viapoint = 19;
  if (has_weight_viapoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(19, this->weight_viapoint(), target);
  }

  // optional float weight_adapt_factor = 20;
  if (has_weight_adapt_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(20, this->weight_adapt_factor(), target);
  }

  // optional float weight_prefer_rotdir = 21;
  if (has_weight_prefer_rotdir()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->weight_prefer_rotdir(), target);
  }

  // optional float weight_acc_lim_theta = 22;
  if (has_weight_acc_lim_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(22, this->weight_acc_lim_theta(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Optimization)
  return target;
}

int Optimization::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Optimization)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int32 no_inner_iterations = 1;
    if (has_no_inner_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->no_inner_iterations());
    }

    // optional int32 no_outer_iterations = 2;
    if (has_no_outer_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->no_outer_iterations());
    }

    // optional bool optimization_activate = 3;
    if (has_optimization_activate()) {
      total_size += 1 + 1;
    }

    // optional bool optimization_verbose = 4;
    if (has_optimization_verbose()) {
      total_size += 1 + 1;
    }

    // optional float penalty_epsilon = 5;
    if (has_penalty_epsilon()) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_x = 6;
    if (has_weight_max_vel_x()) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_y = 7;
    if (has_weight_max_vel_y()) {
      total_size += 1 + 4;
    }

    // optional float weight_max_vel_theta = 8;
    if (has_weight_max_vel_theta()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional float weight_acc_lim_x = 9;
    if (has_weight_acc_lim_x()) {
      total_size += 1 + 4;
    }

    // optional float weight_acc_lim_y = 10;
    if (has_weight_acc_lim_y()) {
      total_size += 1 + 4;
    }

    // optional float weight_acc_lim_thet = 11;
    if (has_weight_acc_lim_thet()) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_nh = 12;
    if (has_weight_kinematics_nh()) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_forward_drive = 13;
    if (has_weight_kinematics_forward_drive()) {
      total_size += 1 + 4;
    }

    // optional float weight_kinematics_turning_radius = 14;
    if (has_weight_kinematics_turning_radius()) {
      total_size += 1 + 4;
    }

    // optional float weight_optimaltime = 15;
    if (has_weight_optimaltime()) {
      total_size += 1 + 4;
    }

    // optional float weight_obstacle = 16;
    if (has_weight_obstacle()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & 4128768u) {
    // optional float weight_inflation = 17;
    if (has_weight_inflation()) {
      total_size += 2 + 4;
    }

    // optional float weight_dynamic_obstacle = 18;
    if (has_weight_dynamic_obstacle()) {
      total_size += 2 + 4;
    }

    // optional float weight_viapoint = 19;
    if (has_weight_viapoint()) {
      total_size += 2 + 4;
    }

    // optional float weight_adapt_factor = 20;
    if (has_weight_adapt_factor()) {
      total_size += 2 + 4;
    }

    // optional float weight_prefer_rotdir = 21;
    if (has_weight_prefer_rotdir()) {
      total_size += 2 + 4;
    }

    // optional float weight_acc_lim_theta = 22;
    if (has_weight_acc_lim_theta()) {
      total_size += 2 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Optimization::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Optimization)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Optimization* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Optimization>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Optimization)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Optimization)
    MergeFrom(*source);
  }
}

void Optimization::MergeFrom(const Optimization& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Optimization)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_no_inner_iterations()) {
      set_no_inner_iterations(from.no_inner_iterations());
    }
    if (from.has_no_outer_iterations()) {
      set_no_outer_iterations(from.no_outer_iterations());
    }
    if (from.has_optimization_activate()) {
      set_optimization_activate(from.optimization_activate());
    }
    if (from.has_optimization_verbose()) {
      set_optimization_verbose(from.optimization_verbose());
    }
    if (from.has_penalty_epsilon()) {
      set_penalty_epsilon(from.penalty_epsilon());
    }
    if (from.has_weight_max_vel_x()) {
      set_weight_max_vel_x(from.weight_max_vel_x());
    }
    if (from.has_weight_max_vel_y()) {
      set_weight_max_vel_y(from.weight_max_vel_y());
    }
    if (from.has_weight_max_vel_theta()) {
      set_weight_max_vel_theta(from.weight_max_vel_theta());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_weight_acc_lim_x()) {
      set_weight_acc_lim_x(from.weight_acc_lim_x());
    }
    if (from.has_weight_acc_lim_y()) {
      set_weight_acc_lim_y(from.weight_acc_lim_y());
    }
    if (from.has_weight_acc_lim_thet()) {
      set_weight_acc_lim_thet(from.weight_acc_lim_thet());
    }
    if (from.has_weight_kinematics_nh()) {
      set_weight_kinematics_nh(from.weight_kinematics_nh());
    }
    if (from.has_weight_kinematics_forward_drive()) {
      set_weight_kinematics_forward_drive(from.weight_kinematics_forward_drive());
    }
    if (from.has_weight_kinematics_turning_radius()) {
      set_weight_kinematics_turning_radius(from.weight_kinematics_turning_radius());
    }
    if (from.has_weight_optimaltime()) {
      set_weight_optimaltime(from.weight_optimaltime());
    }
    if (from.has_weight_obstacle()) {
      set_weight_obstacle(from.weight_obstacle());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_weight_inflation()) {
      set_weight_inflation(from.weight_inflation());
    }
    if (from.has_weight_dynamic_obstacle()) {
      set_weight_dynamic_obstacle(from.weight_dynamic_obstacle());
    }
    if (from.has_weight_viapoint()) {
      set_weight_viapoint(from.weight_viapoint());
    }
    if (from.has_weight_adapt_factor()) {
      set_weight_adapt_factor(from.weight_adapt_factor());
    }
    if (from.has_weight_prefer_rotdir()) {
      set_weight_prefer_rotdir(from.weight_prefer_rotdir());
    }
    if (from.has_weight_acc_lim_theta()) {
      set_weight_acc_lim_theta(from.weight_acc_lim_theta());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Optimization::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Optimization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Optimization::CopyFrom(const Optimization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Optimization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optimization::IsInitialized() const {

  return true;
}

void Optimization::Swap(Optimization* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Optimization::InternalSwap(Optimization* other) {
  std::swap(no_inner_iterations_, other->no_inner_iterations_);
  std::swap(no_outer_iterations_, other->no_outer_iterations_);
  std::swap(optimization_activate_, other->optimization_activate_);
  std::swap(optimization_verbose_, other->optimization_verbose_);
  std::swap(penalty_epsilon_, other->penalty_epsilon_);
  std::swap(weight_max_vel_x_, other->weight_max_vel_x_);
  std::swap(weight_max_vel_y_, other->weight_max_vel_y_);
  std::swap(weight_max_vel_theta_, other->weight_max_vel_theta_);
  std::swap(weight_acc_lim_x_, other->weight_acc_lim_x_);
  std::swap(weight_acc_lim_y_, other->weight_acc_lim_y_);
  std::swap(weight_acc_lim_thet_, other->weight_acc_lim_thet_);
  std::swap(weight_kinematics_nh_, other->weight_kinematics_nh_);
  std::swap(weight_kinematics_forward_drive_, other->weight_kinematics_forward_drive_);
  std::swap(weight_kinematics_turning_radius_, other->weight_kinematics_turning_radius_);
  std::swap(weight_optimaltime_, other->weight_optimaltime_);
  std::swap(weight_obstacle_, other->weight_obstacle_);
  std::swap(weight_inflation_, other->weight_inflation_);
  std::swap(weight_dynamic_obstacle_, other->weight_dynamic_obstacle_);
  std::swap(weight_viapoint_, other->weight_viapoint_);
  std::swap(weight_adapt_factor_, other->weight_adapt_factor_);
  std::swap(weight_prefer_rotdir_, other->weight_prefer_rotdir_);
  std::swap(weight_acc_lim_theta_, other->weight_acc_lim_theta_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Optimization::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Optimization_descriptor_;
  metadata.reflection = Optimization_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Optimization

// optional int32 no_inner_iterations = 1;
bool Optimization::has_no_inner_iterations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Optimization::set_has_no_inner_iterations() {
  _has_bits_[0] |= 0x00000001u;
}
void Optimization::clear_has_no_inner_iterations() {
  _has_bits_[0] &= ~0x00000001u;
}
void Optimization::clear_no_inner_iterations() {
  no_inner_iterations_ = 0;
  clear_has_no_inner_iterations();
}
 ::google::protobuf::int32 Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_inner_iterations)
  return no_inner_iterations_;
}
 void Optimization::set_no_inner_iterations(::google::protobuf::int32 value) {
  set_has_no_inner_iterations();
  no_inner_iterations_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
bool Optimization::has_no_outer_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Optimization::set_has_no_outer_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
void Optimization::clear_has_no_outer_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
void Optimization::clear_no_outer_iterations() {
  no_outer_iterations_ = 0;
  clear_has_no_outer_iterations();
}
 ::google::protobuf::int32 Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_outer_iterations)
  return no_outer_iterations_;
}
 void Optimization::set_no_outer_iterations(::google::protobuf::int32 value) {
  set_has_no_outer_iterations();
  no_outer_iterations_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
bool Optimization::has_optimization_activate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Optimization::set_has_optimization_activate() {
  _has_bits_[0] |= 0x00000004u;
}
void Optimization::clear_has_optimization_activate() {
  _has_bits_[0] &= ~0x00000004u;
}
void Optimization::clear_optimization_activate() {
  optimization_activate_ = false;
  clear_has_optimization_activate();
}
 bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_activate)
  return optimization_activate_;
}
 void Optimization::set_optimization_activate(bool value) {
  set_has_optimization_activate();
  optimization_activate_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
bool Optimization::has_optimization_verbose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Optimization::set_has_optimization_verbose() {
  _has_bits_[0] |= 0x00000008u;
}
void Optimization::clear_has_optimization_verbose() {
  _has_bits_[0] &= ~0x00000008u;
}
void Optimization::clear_optimization_verbose() {
  optimization_verbose_ = false;
  clear_has_optimization_verbose();
}
 bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_verbose)
  return optimization_verbose_;
}
 void Optimization::set_optimization_verbose(bool value) {
  set_has_optimization_verbose();
  optimization_verbose_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_verbose)
}

// optional float penalty_epsilon = 5;
bool Optimization::has_penalty_epsilon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Optimization::set_has_penalty_epsilon() {
  _has_bits_[0] |= 0x00000010u;
}
void Optimization::clear_has_penalty_epsilon() {
  _has_bits_[0] &= ~0x00000010u;
}
void Optimization::clear_penalty_epsilon() {
  penalty_epsilon_ = 0;
  clear_has_penalty_epsilon();
}
 float Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.penalty_epsilon)
  return penalty_epsilon_;
}
 void Optimization::set_penalty_epsilon(float value) {
  set_has_penalty_epsilon();
  penalty_epsilon_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.penalty_epsilon)
}

// optional float weight_max_vel_x = 6;
bool Optimization::has_weight_max_vel_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Optimization::set_has_weight_max_vel_x() {
  _has_bits_[0] |= 0x00000020u;
}
void Optimization::clear_has_weight_max_vel_x() {
  _has_bits_[0] &= ~0x00000020u;
}
void Optimization::clear_weight_max_vel_x() {
  weight_max_vel_x_ = 0;
  clear_has_weight_max_vel_x();
}
 float Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_x)
  return weight_max_vel_x_;
}
 void Optimization::set_weight_max_vel_x(float value) {
  set_has_weight_max_vel_x();
  weight_max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_x)
}

// optional float weight_max_vel_y = 7;
bool Optimization::has_weight_max_vel_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Optimization::set_has_weight_max_vel_y() {
  _has_bits_[0] |= 0x00000040u;
}
void Optimization::clear_has_weight_max_vel_y() {
  _has_bits_[0] &= ~0x00000040u;
}
void Optimization::clear_weight_max_vel_y() {
  weight_max_vel_y_ = 0;
  clear_has_weight_max_vel_y();
}
 float Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_y)
  return weight_max_vel_y_;
}
 void Optimization::set_weight_max_vel_y(float value) {
  set_has_weight_max_vel_y();
  weight_max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_y)
}

// optional float weight_max_vel_theta = 8;
bool Optimization::has_weight_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Optimization::set_has_weight_max_vel_theta() {
  _has_bits_[0] |= 0x00000080u;
}
void Optimization::clear_has_weight_max_vel_theta() {
  _has_bits_[0] &= ~0x00000080u;
}
void Optimization::clear_weight_max_vel_theta() {
  weight_max_vel_theta_ = 0;
  clear_has_weight_max_vel_theta();
}
 float Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_theta)
  return weight_max_vel_theta_;
}
 void Optimization::set_weight_max_vel_theta(float value) {
  set_has_weight_max_vel_theta();
  weight_max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_theta)
}

// optional float weight_acc_lim_x = 9;
bool Optimization::has_weight_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Optimization::set_has_weight_acc_lim_x() {
  _has_bits_[0] |= 0x00000100u;
}
void Optimization::clear_has_weight_acc_lim_x() {
  _has_bits_[0] &= ~0x00000100u;
}
void Optimization::clear_weight_acc_lim_x() {
  weight_acc_lim_x_ = 0;
  clear_has_weight_acc_lim_x();
}
 float Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_x)
  return weight_acc_lim_x_;
}
 void Optimization::set_weight_acc_lim_x(float value) {
  set_has_weight_acc_lim_x();
  weight_acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_x)
}

// optional float weight_acc_lim_y = 10;
bool Optimization::has_weight_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Optimization::set_has_weight_acc_lim_y() {
  _has_bits_[0] |= 0x00000200u;
}
void Optimization::clear_has_weight_acc_lim_y() {
  _has_bits_[0] &= ~0x00000200u;
}
void Optimization::clear_weight_acc_lim_y() {
  weight_acc_lim_y_ = 0;
  clear_has_weight_acc_lim_y();
}
 float Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_y)
  return weight_acc_lim_y_;
}
 void Optimization::set_weight_acc_lim_y(float value) {
  set_has_weight_acc_lim_y();
  weight_acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_y)
}

// optional float weight_acc_lim_thet = 11;
bool Optimization::has_weight_acc_lim_thet() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Optimization::set_has_weight_acc_lim_thet() {
  _has_bits_[0] |= 0x00000400u;
}
void Optimization::clear_has_weight_acc_lim_thet() {
  _has_bits_[0] &= ~0x00000400u;
}
void Optimization::clear_weight_acc_lim_thet() {
  weight_acc_lim_thet_ = 0;
  clear_has_weight_acc_lim_thet();
}
 float Optimization::weight_acc_lim_thet() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_thet)
  return weight_acc_lim_thet_;
}
 void Optimization::set_weight_acc_lim_thet(float value) {
  set_has_weight_acc_lim_thet();
  weight_acc_lim_thet_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_thet)
}

// optional float weight_kinematics_nh = 12;
bool Optimization::has_weight_kinematics_nh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Optimization::set_has_weight_kinematics_nh() {
  _has_bits_[0] |= 0x00000800u;
}
void Optimization::clear_has_weight_kinematics_nh() {
  _has_bits_[0] &= ~0x00000800u;
}
void Optimization::clear_weight_kinematics_nh() {
  weight_kinematics_nh_ = 0;
  clear_has_weight_kinematics_nh();
}
 float Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_nh)
  return weight_kinematics_nh_;
}
 void Optimization::set_weight_kinematics_nh(float value) {
  set_has_weight_kinematics_nh();
  weight_kinematics_nh_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_nh)
}

// optional float weight_kinematics_forward_drive = 13;
bool Optimization::has_weight_kinematics_forward_drive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Optimization::set_has_weight_kinematics_forward_drive() {
  _has_bits_[0] |= 0x00001000u;
}
void Optimization::clear_has_weight_kinematics_forward_drive() {
  _has_bits_[0] &= ~0x00001000u;
}
void Optimization::clear_weight_kinematics_forward_drive() {
  weight_kinematics_forward_drive_ = 0;
  clear_has_weight_kinematics_forward_drive();
}
 float Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
  return weight_kinematics_forward_drive_;
}
 void Optimization::set_weight_kinematics_forward_drive(float value) {
  set_has_weight_kinematics_forward_drive();
  weight_kinematics_forward_drive_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
}

// optional float weight_kinematics_turning_radius = 14;
bool Optimization::has_weight_kinematics_turning_radius() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Optimization::set_has_weight_kinematics_turning_radius() {
  _has_bits_[0] |= 0x00002000u;
}
void Optimization::clear_has_weight_kinematics_turning_radius() {
  _has_bits_[0] &= ~0x00002000u;
}
void Optimization::clear_weight_kinematics_turning_radius() {
  weight_kinematics_turning_radius_ = 0;
  clear_has_weight_kinematics_turning_radius();
}
 float Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
  return weight_kinematics_turning_radius_;
}
 void Optimization::set_weight_kinematics_turning_radius(float value) {
  set_has_weight_kinematics_turning_radius();
  weight_kinematics_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
}

// optional float weight_optimaltime = 15;
bool Optimization::has_weight_optimaltime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Optimization::set_has_weight_optimaltime() {
  _has_bits_[0] |= 0x00004000u;
}
void Optimization::clear_has_weight_optimaltime() {
  _has_bits_[0] &= ~0x00004000u;
}
void Optimization::clear_weight_optimaltime() {
  weight_optimaltime_ = 0;
  clear_has_weight_optimaltime();
}
 float Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_optimaltime)
  return weight_optimaltime_;
}
 void Optimization::set_weight_optimaltime(float value) {
  set_has_weight_optimaltime();
  weight_optimaltime_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_optimaltime)
}

// optional float weight_obstacle = 16;
bool Optimization::has_weight_obstacle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void Optimization::set_has_weight_obstacle() {
  _has_bits_[0] |= 0x00008000u;
}
void Optimization::clear_has_weight_obstacle() {
  _has_bits_[0] &= ~0x00008000u;
}
void Optimization::clear_weight_obstacle() {
  weight_obstacle_ = 0;
  clear_has_weight_obstacle();
}
 float Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_obstacle)
  return weight_obstacle_;
}
 void Optimization::set_weight_obstacle(float value) {
  set_has_weight_obstacle();
  weight_obstacle_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_obstacle)
}

// optional float weight_inflation = 17;
bool Optimization::has_weight_inflation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void Optimization::set_has_weight_inflation() {
  _has_bits_[0] |= 0x00010000u;
}
void Optimization::clear_has_weight_inflation() {
  _has_bits_[0] &= ~0x00010000u;
}
void Optimization::clear_weight_inflation() {
  weight_inflation_ = 0;
  clear_has_weight_inflation();
}
 float Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_inflation)
  return weight_inflation_;
}
 void Optimization::set_weight_inflation(float value) {
  set_has_weight_inflation();
  weight_inflation_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_inflation)
}

// optional float weight_dynamic_obstacle = 18;
bool Optimization::has_weight_dynamic_obstacle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void Optimization::set_has_weight_dynamic_obstacle() {
  _has_bits_[0] |= 0x00020000u;
}
void Optimization::clear_has_weight_dynamic_obstacle() {
  _has_bits_[0] &= ~0x00020000u;
}
void Optimization::clear_weight_dynamic_obstacle() {
  weight_dynamic_obstacle_ = 0;
  clear_has_weight_dynamic_obstacle();
}
 float Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_dynamic_obstacle)
  return weight_dynamic_obstacle_;
}
 void Optimization::set_weight_dynamic_obstacle(float value) {
  set_has_weight_dynamic_obstacle();
  weight_dynamic_obstacle_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_dynamic_obstacle)
}

// optional float weight_viapoint = 19;
bool Optimization::has_weight_viapoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void Optimization::set_has_weight_viapoint() {
  _has_bits_[0] |= 0x00040000u;
}
void Optimization::clear_has_weight_viapoint() {
  _has_bits_[0] &= ~0x00040000u;
}
void Optimization::clear_weight_viapoint() {
  weight_viapoint_ = 0;
  clear_has_weight_viapoint();
}
 float Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_viapoint)
  return weight_viapoint_;
}
 void Optimization::set_weight_viapoint(float value) {
  set_has_weight_viapoint();
  weight_viapoint_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_viapoint)
}

// optional float weight_adapt_factor = 20;
bool Optimization::has_weight_adapt_factor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void Optimization::set_has_weight_adapt_factor() {
  _has_bits_[0] |= 0x00080000u;
}
void Optimization::clear_has_weight_adapt_factor() {
  _has_bits_[0] &= ~0x00080000u;
}
void Optimization::clear_weight_adapt_factor() {
  weight_adapt_factor_ = 0;
  clear_has_weight_adapt_factor();
}
 float Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_adapt_factor)
  return weight_adapt_factor_;
}
 void Optimization::set_weight_adapt_factor(float value) {
  set_has_weight_adapt_factor();
  weight_adapt_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_adapt_factor)
}

// optional float weight_prefer_rotdir = 21;
bool Optimization::has_weight_prefer_rotdir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void Optimization::set_has_weight_prefer_rotdir() {
  _has_bits_[0] |= 0x00100000u;
}
void Optimization::clear_has_weight_prefer_rotdir() {
  _has_bits_[0] &= ~0x00100000u;
}
void Optimization::clear_weight_prefer_rotdir() {
  weight_prefer_rotdir_ = 0;
  clear_has_weight_prefer_rotdir();
}
 float Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_prefer_rotdir)
  return weight_prefer_rotdir_;
}
 void Optimization::set_weight_prefer_rotdir(float value) {
  set_has_weight_prefer_rotdir();
  weight_prefer_rotdir_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_prefer_rotdir)
}

// optional float weight_acc_lim_theta = 22;
bool Optimization::has_weight_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void Optimization::set_has_weight_acc_lim_theta() {
  _has_bits_[0] |= 0x00200000u;
}
void Optimization::clear_has_weight_acc_lim_theta() {
  _has_bits_[0] &= ~0x00200000u;
}
void Optimization::clear_weight_acc_lim_theta() {
  weight_acc_lim_theta_ = 0;
  clear_has_weight_acc_lim_theta();
}
 float Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_theta)
  return weight_acc_lim_theta_;
}
 void Optimization::set_weight_acc_lim_theta(float value) {
  set_has_weight_acc_lim_theta();
  weight_acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_theta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HomotopyClassPlanner::kEnableHomotopyClassPlanningFieldNumber;
const int HomotopyClassPlanner::kEnableMultithreadingFieldNumber;
const int HomotopyClassPlanner::kSimpleExplorationFieldNumber;
const int HomotopyClassPlanner::kMaxNumberClassesFieldNumber;
const int HomotopyClassPlanner::kSelectionObstCostScaleFieldNumber;
const int HomotopyClassPlanner::kSelectionPreferInitialPlanFieldNumber;
const int HomotopyClassPlanner::kSelectionViapointCostScaleFieldNumber;
const int HomotopyClassPlanner::kSelectionCostHysteresisFieldNumber;
const int HomotopyClassPlanner::kSelectionAlternativeTimeCostFieldNumber;
const int HomotopyClassPlanner::kRoadmapGraphNoSamplesFieldNumber;
const int HomotopyClassPlanner::kRoadmapGraphAreaWidthFieldNumber;
const int HomotopyClassPlanner::kRoadmapGraphAreaLengthScaleFieldNumber;
const int HomotopyClassPlanner::kHSignaturePrescalerFieldNumber;
const int HomotopyClassPlanner::kHSignatureThresholdFieldNumber;
const int HomotopyClassPlanner::kObstacleKeypointOffsetFieldNumber;
const int HomotopyClassPlanner::kObstacleHeadingThresholdFieldNumber;
const int HomotopyClassPlanner::kViapointsAllCandidatesFieldNumber;
const int HomotopyClassPlanner::kVisualizeHcGraphFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HomotopyClassPlanner::HomotopyClassPlanner()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.HomotopyClassPlanner)
}

void HomotopyClassPlanner::InitAsDefaultInstance() {
}

HomotopyClassPlanner::HomotopyClassPlanner(const HomotopyClassPlanner& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.HomotopyClassPlanner)
}

void HomotopyClassPlanner::SharedCtor() {
  _cached_size_ = 0;
  enable_homotopy_class_planning_ = false;
  enable_multithreading_ = false;
  simple_exploration_ = false;
  max_number_classes_ = 0;
  selection_obst_cost_scale_ = 0;
  selection_prefer_initial_plan_ = 0;
  selection_viapoint_cost_scale_ = 0;
  selection_cost_hysteresis_ = 0;
  selection_alternative_time_cost_ = false;
  roadmap_graph_no_samples_ = 0;
  roadmap_graph_area_width_ = 0;
  roadmap_graph_area_length_scale_ = 0;
  h_signature_prescaler_ = 0;
  h_signature_threshold_ = 0;
  obstacle_keypoint_offset_ = 0;
  obstacle_heading_threshold_ = 0;
  viapoints_all_candidates_ = false;
  visualize_hc_graph_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HomotopyClassPlanner::~HomotopyClassPlanner() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.HomotopyClassPlanner)
  SharedDtor();
}

void HomotopyClassPlanner::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HomotopyClassPlanner::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HomotopyClassPlanner::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HomotopyClassPlanner_descriptor_;
}

const HomotopyClassPlanner& HomotopyClassPlanner::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

HomotopyClassPlanner* HomotopyClassPlanner::default_instance_ = NULL;

HomotopyClassPlanner* HomotopyClassPlanner::New(::google::protobuf::Arena* arena) const {
  HomotopyClassPlanner* n = new HomotopyClassPlanner;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HomotopyClassPlanner::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.HomotopyClassPlanner)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(HomotopyClassPlanner, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<HomotopyClassPlanner*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(enable_homotopy_class_planning_, simple_exploration_);
    ZR_(max_number_classes_, selection_cost_hysteresis_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(roadmap_graph_no_samples_, obstacle_heading_threshold_);
    selection_alternative_time_cost_ = false;
  }
  ZR_(viapoints_all_candidates_, visualize_hc_graph_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HomotopyClassPlanner::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.HomotopyClassPlanner)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool enable_homotopy_class_planning = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_homotopy_class_planning_)));
          set_has_enable_homotopy_class_planning();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_enable_multithreading;
        break;
      }

      // optional bool enable_multithreading = 2;
      case 2: {
        if (tag == 16) {
         parse_enable_multithreading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_multithreading_)));
          set_has_enable_multithreading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_simple_exploration;
        break;
      }

      // optional bool simple_exploration = 3;
      case 3: {
        if (tag == 24) {
         parse_simple_exploration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &simple_exploration_)));
          set_has_simple_exploration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_max_number_classes;
        break;
      }

      // optional int32 max_number_classes = 4;
      case 4: {
        if (tag == 32) {
         parse_max_number_classes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_number_classes_)));
          set_has_max_number_classes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_selection_obst_cost_scale;
        break;
      }

      // optional float selection_obst_cost_scale = 5;
      case 5: {
        if (tag == 45) {
         parse_selection_obst_cost_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &selection_obst_cost_scale_)));
          set_has_selection_obst_cost_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_selection_prefer_initial_plan;
        break;
      }

      // optional float selection_prefer_initial_plan = 6;
      case 6: {
        if (tag == 53) {
         parse_selection_prefer_initial_plan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &selection_prefer_initial_plan_)));
          set_has_selection_prefer_initial_plan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_selection_viapoint_cost_scale;
        break;
      }

      // optional float selection_viapoint_cost_scale = 7;
      case 7: {
        if (tag == 61) {
         parse_selection_viapoint_cost_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &selection_viapoint_cost_scale_)));
          set_has_selection_viapoint_cost_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_selection_cost_hysteresis;
        break;
      }

      // optional float selection_cost_hysteresis = 8;
      case 8: {
        if (tag == 69) {
         parse_selection_cost_hysteresis:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &selection_cost_hysteresis_)));
          set_has_selection_cost_hysteresis();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_selection_alternative_time_cost;
        break;
      }

      // optional bool selection_alternative_time_cost = 9;
      case 9: {
        if (tag == 72) {
         parse_selection_alternative_time_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &selection_alternative_time_cost_)));
          set_has_selection_alternative_time_cost();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_roadmap_graph_no_samples;
        break;
      }

      // optional int32 roadmap_graph_no_samples = 10;
      case 10: {
        if (tag == 80) {
         parse_roadmap_graph_no_samples:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &roadmap_graph_no_samples_)));
          set_has_roadmap_graph_no_samples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_roadmap_graph_area_width;
        break;
      }

      // optional int32 roadmap_graph_area_width = 11;
      case 11: {
        if (tag == 88) {
         parse_roadmap_graph_area_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &roadmap_graph_area_width_)));
          set_has_roadmap_graph_area_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_roadmap_graph_area_length_scale;
        break;
      }

      // optional float roadmap_graph_area_length_scale = 12;
      case 12: {
        if (tag == 101) {
         parse_roadmap_graph_area_length_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roadmap_graph_area_length_scale_)));
          set_has_roadmap_graph_area_length_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(109)) goto parse_h_signature_prescaler;
        break;
      }

      // optional float h_signature_prescaler = 13;
      case 13: {
        if (tag == 109) {
         parse_h_signature_prescaler:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &h_signature_prescaler_)));
          set_has_h_signature_prescaler();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(117)) goto parse_h_signature_threshold;
        break;
      }

      // optional float h_signature_threshold = 14;
      case 14: {
        if (tag == 117) {
         parse_h_signature_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &h_signature_threshold_)));
          set_has_h_signature_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(125)) goto parse_obstacle_keypoint_offset;
        break;
      }

      // optional float obstacle_keypoint_offset = 15;
      case 15: {
        if (tag == 125) {
         parse_obstacle_keypoint_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obstacle_keypoint_offset_)));
          set_has_obstacle_keypoint_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(133)) goto parse_obstacle_heading_threshold;
        break;
      }

      // optional float obstacle_heading_threshold = 16;
      case 16: {
        if (tag == 133) {
         parse_obstacle_heading_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obstacle_heading_threshold_)));
          set_has_obstacle_heading_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_viapoints_all_candidates;
        break;
      }

      // optional bool viapoints_all_candidates = 17;
      case 17: {
        if (tag == 136) {
         parse_viapoints_all_candidates:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &viapoints_all_candidates_)));
          set_has_viapoints_all_candidates();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_visualize_hc_graph;
        break;
      }

      // optional bool visualize_hc_graph = 18;
      case 18: {
        if (tag == 144) {
         parse_visualize_hc_graph:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visualize_hc_graph_)));
          set_has_visualize_hc_graph();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.HomotopyClassPlanner)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.HomotopyClassPlanner)
  return false;
#undef DO_
}

void HomotopyClassPlanner::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.HomotopyClassPlanner)
  // optional bool enable_homotopy_class_planning = 1;
  if (has_enable_homotopy_class_planning()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enable_homotopy_class_planning(), output);
  }

  // optional bool enable_multithreading = 2;
  if (has_enable_multithreading()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->enable_multithreading(), output);
  }

  // optional bool simple_exploration = 3;
  if (has_simple_exploration()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->simple_exploration(), output);
  }

  // optional int32 max_number_classes = 4;
  if (has_max_number_classes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->max_number_classes(), output);
  }

  // optional float selection_obst_cost_scale = 5;
  if (has_selection_obst_cost_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->selection_obst_cost_scale(), output);
  }

  // optional float selection_prefer_initial_plan = 6;
  if (has_selection_prefer_initial_plan()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->selection_prefer_initial_plan(), output);
  }

  // optional float selection_viapoint_cost_scale = 7;
  if (has_selection_viapoint_cost_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->selection_viapoint_cost_scale(), output);
  }

  // optional float selection_cost_hysteresis = 8;
  if (has_selection_cost_hysteresis()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->selection_cost_hysteresis(), output);
  }

  // optional bool selection_alternative_time_cost = 9;
  if (has_selection_alternative_time_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->selection_alternative_time_cost(), output);
  }

  // optional int32 roadmap_graph_no_samples = 10;
  if (has_roadmap_graph_no_samples()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->roadmap_graph_no_samples(), output);
  }

  // optional int32 roadmap_graph_area_width = 11;
  if (has_roadmap_graph_area_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->roadmap_graph_area_width(), output);
  }

  // optional float roadmap_graph_area_length_scale = 12;
  if (has_roadmap_graph_area_length_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->roadmap_graph_area_length_scale(), output);
  }

  // optional float h_signature_prescaler = 13;
  if (has_h_signature_prescaler()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->h_signature_prescaler(), output);
  }

  // optional float h_signature_threshold = 14;
  if (has_h_signature_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->h_signature_threshold(), output);
  }

  // optional float obstacle_keypoint_offset = 15;
  if (has_obstacle_keypoint_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->obstacle_keypoint_offset(), output);
  }

  // optional float obstacle_heading_threshold = 16;
  if (has_obstacle_heading_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->obstacle_heading_threshold(), output);
  }

  // optional bool viapoints_all_candidates = 17;
  if (has_viapoints_all_candidates()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->viapoints_all_candidates(), output);
  }

  // optional bool visualize_hc_graph = 18;
  if (has_visualize_hc_graph()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->visualize_hc_graph(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.HomotopyClassPlanner)
}

::google::protobuf::uint8* HomotopyClassPlanner::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.HomotopyClassPlanner)
  // optional bool enable_homotopy_class_planning = 1;
  if (has_enable_homotopy_class_planning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->enable_homotopy_class_planning(), target);
  }

  // optional bool enable_multithreading = 2;
  if (has_enable_multithreading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->enable_multithreading(), target);
  }

  // optional bool simple_exploration = 3;
  if (has_simple_exploration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->simple_exploration(), target);
  }

  // optional int32 max_number_classes = 4;
  if (has_max_number_classes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->max_number_classes(), target);
  }

  // optional float selection_obst_cost_scale = 5;
  if (has_selection_obst_cost_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->selection_obst_cost_scale(), target);
  }

  // optional float selection_prefer_initial_plan = 6;
  if (has_selection_prefer_initial_plan()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->selection_prefer_initial_plan(), target);
  }

  // optional float selection_viapoint_cost_scale = 7;
  if (has_selection_viapoint_cost_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->selection_viapoint_cost_scale(), target);
  }

  // optional float selection_cost_hysteresis = 8;
  if (has_selection_cost_hysteresis()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->selection_cost_hysteresis(), target);
  }

  // optional bool selection_alternative_time_cost = 9;
  if (has_selection_alternative_time_cost()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->selection_alternative_time_cost(), target);
  }

  // optional int32 roadmap_graph_no_samples = 10;
  if (has_roadmap_graph_no_samples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->roadmap_graph_no_samples(), target);
  }

  // optional int32 roadmap_graph_area_width = 11;
  if (has_roadmap_graph_area_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->roadmap_graph_area_width(), target);
  }

  // optional float roadmap_graph_area_length_scale = 12;
  if (has_roadmap_graph_area_length_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->roadmap_graph_area_length_scale(), target);
  }

  // optional float h_signature_prescaler = 13;
  if (has_h_signature_prescaler()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->h_signature_prescaler(), target);
  }

  // optional float h_signature_threshold = 14;
  if (has_h_signature_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->h_signature_threshold(), target);
  }

  // optional float obstacle_keypoint_offset = 15;
  if (has_obstacle_keypoint_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->obstacle_keypoint_offset(), target);
  }

  // optional float obstacle_heading_threshold = 16;
  if (has_obstacle_heading_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->obstacle_heading_threshold(), target);
  }

  // optional bool viapoints_all_candidates = 17;
  if (has_viapoints_all_candidates()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->viapoints_all_candidates(), target);
  }

  // optional bool visualize_hc_graph = 18;
  if (has_visualize_hc_graph()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->visualize_hc_graph(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.HomotopyClassPlanner)
  return target;
}

int HomotopyClassPlanner::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.HomotopyClassPlanner)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional bool enable_homotopy_class_planning = 1;
    if (has_enable_homotopy_class_planning()) {
      total_size += 1 + 1;
    }

    // optional bool enable_multithreading = 2;
    if (has_enable_multithreading()) {
      total_size += 1 + 1;
    }

    // optional bool simple_exploration = 3;
    if (has_simple_exploration()) {
      total_size += 1 + 1;
    }

    // optional int32 max_number_classes = 4;
    if (has_max_number_classes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_number_classes());
    }

    // optional float selection_obst_cost_scale = 5;
    if (has_selection_obst_cost_scale()) {
      total_size += 1 + 4;
    }

    // optional float selection_prefer_initial_plan = 6;
    if (has_selection_prefer_initial_plan()) {
      total_size += 1 + 4;
    }

    // optional float selection_viapoint_cost_scale = 7;
    if (has_selection_viapoint_cost_scale()) {
      total_size += 1 + 4;
    }

    // optional float selection_cost_hysteresis = 8;
    if (has_selection_cost_hysteresis()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional bool selection_alternative_time_cost = 9;
    if (has_selection_alternative_time_cost()) {
      total_size += 1 + 1;
    }

    // optional int32 roadmap_graph_no_samples = 10;
    if (has_roadmap_graph_no_samples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->roadmap_graph_no_samples());
    }

    // optional int32 roadmap_graph_area_width = 11;
    if (has_roadmap_graph_area_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->roadmap_graph_area_width());
    }

    // optional float roadmap_graph_area_length_scale = 12;
    if (has_roadmap_graph_area_length_scale()) {
      total_size += 1 + 4;
    }

    // optional float h_signature_prescaler = 13;
    if (has_h_signature_prescaler()) {
      total_size += 1 + 4;
    }

    // optional float h_signature_threshold = 14;
    if (has_h_signature_threshold()) {
      total_size += 1 + 4;
    }

    // optional float obstacle_keypoint_offset = 15;
    if (has_obstacle_keypoint_offset()) {
      total_size += 1 + 4;
    }

    // optional float obstacle_heading_threshold = 16;
    if (has_obstacle_heading_threshold()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & 196608u) {
    // optional bool viapoints_all_candidates = 17;
    if (has_viapoints_all_candidates()) {
      total_size += 2 + 1;
    }

    // optional bool visualize_hc_graph = 18;
    if (has_visualize_hc_graph()) {
      total_size += 2 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HomotopyClassPlanner::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.HomotopyClassPlanner)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HomotopyClassPlanner* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HomotopyClassPlanner>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.HomotopyClassPlanner)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.HomotopyClassPlanner)
    MergeFrom(*source);
  }
}

void HomotopyClassPlanner::MergeFrom(const HomotopyClassPlanner& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.HomotopyClassPlanner)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enable_homotopy_class_planning()) {
      set_enable_homotopy_class_planning(from.enable_homotopy_class_planning());
    }
    if (from.has_enable_multithreading()) {
      set_enable_multithreading(from.enable_multithreading());
    }
    if (from.has_simple_exploration()) {
      set_simple_exploration(from.simple_exploration());
    }
    if (from.has_max_number_classes()) {
      set_max_number_classes(from.max_number_classes());
    }
    if (from.has_selection_obst_cost_scale()) {
      set_selection_obst_cost_scale(from.selection_obst_cost_scale());
    }
    if (from.has_selection_prefer_initial_plan()) {
      set_selection_prefer_initial_plan(from.selection_prefer_initial_plan());
    }
    if (from.has_selection_viapoint_cost_scale()) {
      set_selection_viapoint_cost_scale(from.selection_viapoint_cost_scale());
    }
    if (from.has_selection_cost_hysteresis()) {
      set_selection_cost_hysteresis(from.selection_cost_hysteresis());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_selection_alternative_time_cost()) {
      set_selection_alternative_time_cost(from.selection_alternative_time_cost());
    }
    if (from.has_roadmap_graph_no_samples()) {
      set_roadmap_graph_no_samples(from.roadmap_graph_no_samples());
    }
    if (from.has_roadmap_graph_area_width()) {
      set_roadmap_graph_area_width(from.roadmap_graph_area_width());
    }
    if (from.has_roadmap_graph_area_length_scale()) {
      set_roadmap_graph_area_length_scale(from.roadmap_graph_area_length_scale());
    }
    if (from.has_h_signature_prescaler()) {
      set_h_signature_prescaler(from.h_signature_prescaler());
    }
    if (from.has_h_signature_threshold()) {
      set_h_signature_threshold(from.h_signature_threshold());
    }
    if (from.has_obstacle_keypoint_offset()) {
      set_obstacle_keypoint_offset(from.obstacle_keypoint_offset());
    }
    if (from.has_obstacle_heading_threshold()) {
      set_obstacle_heading_threshold(from.obstacle_heading_threshold());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_viapoints_all_candidates()) {
      set_viapoints_all_candidates(from.viapoints_all_candidates());
    }
    if (from.has_visualize_hc_graph()) {
      set_visualize_hc_graph(from.visualize_hc_graph());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HomotopyClassPlanner::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.HomotopyClassPlanner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HomotopyClassPlanner::CopyFrom(const HomotopyClassPlanner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.HomotopyClassPlanner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HomotopyClassPlanner::IsInitialized() const {

  return true;
}

void HomotopyClassPlanner::Swap(HomotopyClassPlanner* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HomotopyClassPlanner::InternalSwap(HomotopyClassPlanner* other) {
  std::swap(enable_homotopy_class_planning_, other->enable_homotopy_class_planning_);
  std::swap(enable_multithreading_, other->enable_multithreading_);
  std::swap(simple_exploration_, other->simple_exploration_);
  std::swap(max_number_classes_, other->max_number_classes_);
  std::swap(selection_obst_cost_scale_, other->selection_obst_cost_scale_);
  std::swap(selection_prefer_initial_plan_, other->selection_prefer_initial_plan_);
  std::swap(selection_viapoint_cost_scale_, other->selection_viapoint_cost_scale_);
  std::swap(selection_cost_hysteresis_, other->selection_cost_hysteresis_);
  std::swap(selection_alternative_time_cost_, other->selection_alternative_time_cost_);
  std::swap(roadmap_graph_no_samples_, other->roadmap_graph_no_samples_);
  std::swap(roadmap_graph_area_width_, other->roadmap_graph_area_width_);
  std::swap(roadmap_graph_area_length_scale_, other->roadmap_graph_area_length_scale_);
  std::swap(h_signature_prescaler_, other->h_signature_prescaler_);
  std::swap(h_signature_threshold_, other->h_signature_threshold_);
  std::swap(obstacle_keypoint_offset_, other->obstacle_keypoint_offset_);
  std::swap(obstacle_heading_threshold_, other->obstacle_heading_threshold_);
  std::swap(viapoints_all_candidates_, other->viapoints_all_candidates_);
  std::swap(visualize_hc_graph_, other->visualize_hc_graph_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HomotopyClassPlanner::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HomotopyClassPlanner_descriptor_;
  metadata.reflection = HomotopyClassPlanner_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HomotopyClassPlanner

// optional bool enable_homotopy_class_planning = 1;
bool HomotopyClassPlanner::has_enable_homotopy_class_planning() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HomotopyClassPlanner::set_has_enable_homotopy_class_planning() {
  _has_bits_[0] |= 0x00000001u;
}
void HomotopyClassPlanner::clear_has_enable_homotopy_class_planning() {
  _has_bits_[0] &= ~0x00000001u;
}
void HomotopyClassPlanner::clear_enable_homotopy_class_planning() {
  enable_homotopy_class_planning_ = false;
  clear_has_enable_homotopy_class_planning();
}
 bool HomotopyClassPlanner::enable_homotopy_class_planning() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
  return enable_homotopy_class_planning_;
}
 void HomotopyClassPlanner::set_enable_homotopy_class_planning(bool value) {
  set_has_enable_homotopy_class_planning();
  enable_homotopy_class_planning_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
}

// optional bool enable_multithreading = 2;
bool HomotopyClassPlanner::has_enable_multithreading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HomotopyClassPlanner::set_has_enable_multithreading() {
  _has_bits_[0] |= 0x00000002u;
}
void HomotopyClassPlanner::clear_has_enable_multithreading() {
  _has_bits_[0] &= ~0x00000002u;
}
void HomotopyClassPlanner::clear_enable_multithreading() {
  enable_multithreading_ = false;
  clear_has_enable_multithreading();
}
 bool HomotopyClassPlanner::enable_multithreading() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
  return enable_multithreading_;
}
 void HomotopyClassPlanner::set_enable_multithreading(bool value) {
  set_has_enable_multithreading();
  enable_multithreading_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
}

// optional bool simple_exploration = 3;
bool HomotopyClassPlanner::has_simple_exploration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void HomotopyClassPlanner::set_has_simple_exploration() {
  _has_bits_[0] |= 0x00000004u;
}
void HomotopyClassPlanner::clear_has_simple_exploration() {
  _has_bits_[0] &= ~0x00000004u;
}
void HomotopyClassPlanner::clear_simple_exploration() {
  simple_exploration_ = false;
  clear_has_simple_exploration();
}
 bool HomotopyClassPlanner::simple_exploration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
  return simple_exploration_;
}
 void HomotopyClassPlanner::set_simple_exploration(bool value) {
  set_has_simple_exploration();
  simple_exploration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
}

// optional int32 max_number_classes = 4;
bool HomotopyClassPlanner::has_max_number_classes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void HomotopyClassPlanner::set_has_max_number_classes() {
  _has_bits_[0] |= 0x00000008u;
}
void HomotopyClassPlanner::clear_has_max_number_classes() {
  _has_bits_[0] &= ~0x00000008u;
}
void HomotopyClassPlanner::clear_max_number_classes() {
  max_number_classes_ = 0;
  clear_has_max_number_classes();
}
 ::google::protobuf::int32 HomotopyClassPlanner::max_number_classes() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
  return max_number_classes_;
}
 void HomotopyClassPlanner::set_max_number_classes(::google::protobuf::int32 value) {
  set_has_max_number_classes();
  max_number_classes_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
}

// optional float selection_obst_cost_scale = 5;
bool HomotopyClassPlanner::has_selection_obst_cost_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void HomotopyClassPlanner::set_has_selection_obst_cost_scale() {
  _has_bits_[0] |= 0x00000010u;
}
void HomotopyClassPlanner::clear_has_selection_obst_cost_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
void HomotopyClassPlanner::clear_selection_obst_cost_scale() {
  selection_obst_cost_scale_ = 0;
  clear_has_selection_obst_cost_scale();
}
 float HomotopyClassPlanner::selection_obst_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
  return selection_obst_cost_scale_;
}
 void HomotopyClassPlanner::set_selection_obst_cost_scale(float value) {
  set_has_selection_obst_cost_scale();
  selection_obst_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
}

// optional float selection_prefer_initial_plan = 6;
bool HomotopyClassPlanner::has_selection_prefer_initial_plan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void HomotopyClassPlanner::set_has_selection_prefer_initial_plan() {
  _has_bits_[0] |= 0x00000020u;
}
void HomotopyClassPlanner::clear_has_selection_prefer_initial_plan() {
  _has_bits_[0] &= ~0x00000020u;
}
void HomotopyClassPlanner::clear_selection_prefer_initial_plan() {
  selection_prefer_initial_plan_ = 0;
  clear_has_selection_prefer_initial_plan();
}
 float HomotopyClassPlanner::selection_prefer_initial_plan() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
  return selection_prefer_initial_plan_;
}
 void HomotopyClassPlanner::set_selection_prefer_initial_plan(float value) {
  set_has_selection_prefer_initial_plan();
  selection_prefer_initial_plan_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
}

// optional float selection_viapoint_cost_scale = 7;
bool HomotopyClassPlanner::has_selection_viapoint_cost_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void HomotopyClassPlanner::set_has_selection_viapoint_cost_scale() {
  _has_bits_[0] |= 0x00000040u;
}
void HomotopyClassPlanner::clear_has_selection_viapoint_cost_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
void HomotopyClassPlanner::clear_selection_viapoint_cost_scale() {
  selection_viapoint_cost_scale_ = 0;
  clear_has_selection_viapoint_cost_scale();
}
 float HomotopyClassPlanner::selection_viapoint_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
  return selection_viapoint_cost_scale_;
}
 void HomotopyClassPlanner::set_selection_viapoint_cost_scale(float value) {
  set_has_selection_viapoint_cost_scale();
  selection_viapoint_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
}

// optional float selection_cost_hysteresis = 8;
bool HomotopyClassPlanner::has_selection_cost_hysteresis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void HomotopyClassPlanner::set_has_selection_cost_hysteresis() {
  _has_bits_[0] |= 0x00000080u;
}
void HomotopyClassPlanner::clear_has_selection_cost_hysteresis() {
  _has_bits_[0] &= ~0x00000080u;
}
void HomotopyClassPlanner::clear_selection_cost_hysteresis() {
  selection_cost_hysteresis_ = 0;
  clear_has_selection_cost_hysteresis();
}
 float HomotopyClassPlanner::selection_cost_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
  return selection_cost_hysteresis_;
}
 void HomotopyClassPlanner::set_selection_cost_hysteresis(float value) {
  set_has_selection_cost_hysteresis();
  selection_cost_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
}

// optional bool selection_alternative_time_cost = 9;
bool HomotopyClassPlanner::has_selection_alternative_time_cost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void HomotopyClassPlanner::set_has_selection_alternative_time_cost() {
  _has_bits_[0] |= 0x00000100u;
}
void HomotopyClassPlanner::clear_has_selection_alternative_time_cost() {
  _has_bits_[0] &= ~0x00000100u;
}
void HomotopyClassPlanner::clear_selection_alternative_time_cost() {
  selection_alternative_time_cost_ = false;
  clear_has_selection_alternative_time_cost();
}
 bool HomotopyClassPlanner::selection_alternative_time_cost() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
  return selection_alternative_time_cost_;
}
 void HomotopyClassPlanner::set_selection_alternative_time_cost(bool value) {
  set_has_selection_alternative_time_cost();
  selection_alternative_time_cost_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
}

// optional int32 roadmap_graph_no_samples = 10;
bool HomotopyClassPlanner::has_roadmap_graph_no_samples() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void HomotopyClassPlanner::set_has_roadmap_graph_no_samples() {
  _has_bits_[0] |= 0x00000200u;
}
void HomotopyClassPlanner::clear_has_roadmap_graph_no_samples() {
  _has_bits_[0] &= ~0x00000200u;
}
void HomotopyClassPlanner::clear_roadmap_graph_no_samples() {
  roadmap_graph_no_samples_ = 0;
  clear_has_roadmap_graph_no_samples();
}
 ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_no_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
  return roadmap_graph_no_samples_;
}
 void HomotopyClassPlanner::set_roadmap_graph_no_samples(::google::protobuf::int32 value) {
  set_has_roadmap_graph_no_samples();
  roadmap_graph_no_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
}

// optional int32 roadmap_graph_area_width = 11;
bool HomotopyClassPlanner::has_roadmap_graph_area_width() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void HomotopyClassPlanner::set_has_roadmap_graph_area_width() {
  _has_bits_[0] |= 0x00000400u;
}
void HomotopyClassPlanner::clear_has_roadmap_graph_area_width() {
  _has_bits_[0] &= ~0x00000400u;
}
void HomotopyClassPlanner::clear_roadmap_graph_area_width() {
  roadmap_graph_area_width_ = 0;
  clear_has_roadmap_graph_area_width();
}
 ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_area_width() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
  return roadmap_graph_area_width_;
}
 void HomotopyClassPlanner::set_roadmap_graph_area_width(::google::protobuf::int32 value) {
  set_has_roadmap_graph_area_width();
  roadmap_graph_area_width_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
}

// optional float roadmap_graph_area_length_scale = 12;
bool HomotopyClassPlanner::has_roadmap_graph_area_length_scale() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void HomotopyClassPlanner::set_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] |= 0x00000800u;
}
void HomotopyClassPlanner::clear_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] &= ~0x00000800u;
}
void HomotopyClassPlanner::clear_roadmap_graph_area_length_scale() {
  roadmap_graph_area_length_scale_ = 0;
  clear_has_roadmap_graph_area_length_scale();
}
 float HomotopyClassPlanner::roadmap_graph_area_length_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
  return roadmap_graph_area_length_scale_;
}
 void HomotopyClassPlanner::set_roadmap_graph_area_length_scale(float value) {
  set_has_roadmap_graph_area_length_scale();
  roadmap_graph_area_length_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
}

// optional float h_signature_prescaler = 13;
bool HomotopyClassPlanner::has_h_signature_prescaler() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void HomotopyClassPlanner::set_has_h_signature_prescaler() {
  _has_bits_[0] |= 0x00001000u;
}
void HomotopyClassPlanner::clear_has_h_signature_prescaler() {
  _has_bits_[0] &= ~0x00001000u;
}
void HomotopyClassPlanner::clear_h_signature_prescaler() {
  h_signature_prescaler_ = 0;
  clear_has_h_signature_prescaler();
}
 float HomotopyClassPlanner::h_signature_prescaler() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
  return h_signature_prescaler_;
}
 void HomotopyClassPlanner::set_h_signature_prescaler(float value) {
  set_has_h_signature_prescaler();
  h_signature_prescaler_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
}

// optional float h_signature_threshold = 14;
bool HomotopyClassPlanner::has_h_signature_threshold() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void HomotopyClassPlanner::set_has_h_signature_threshold() {
  _has_bits_[0] |= 0x00002000u;
}
void HomotopyClassPlanner::clear_has_h_signature_threshold() {
  _has_bits_[0] &= ~0x00002000u;
}
void HomotopyClassPlanner::clear_h_signature_threshold() {
  h_signature_threshold_ = 0;
  clear_has_h_signature_threshold();
}
 float HomotopyClassPlanner::h_signature_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
  return h_signature_threshold_;
}
 void HomotopyClassPlanner::set_h_signature_threshold(float value) {
  set_has_h_signature_threshold();
  h_signature_threshold_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
}

// optional float obstacle_keypoint_offset = 15;
bool HomotopyClassPlanner::has_obstacle_keypoint_offset() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void HomotopyClassPlanner::set_has_obstacle_keypoint_offset() {
  _has_bits_[0] |= 0x00004000u;
}
void HomotopyClassPlanner::clear_has_obstacle_keypoint_offset() {
  _has_bits_[0] &= ~0x00004000u;
}
void HomotopyClassPlanner::clear_obstacle_keypoint_offset() {
  obstacle_keypoint_offset_ = 0;
  clear_has_obstacle_keypoint_offset();
}
 float HomotopyClassPlanner::obstacle_keypoint_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
  return obstacle_keypoint_offset_;
}
 void HomotopyClassPlanner::set_obstacle_keypoint_offset(float value) {
  set_has_obstacle_keypoint_offset();
  obstacle_keypoint_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
}

// optional float obstacle_heading_threshold = 16;
bool HomotopyClassPlanner::has_obstacle_heading_threshold() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void HomotopyClassPlanner::set_has_obstacle_heading_threshold() {
  _has_bits_[0] |= 0x00008000u;
}
void HomotopyClassPlanner::clear_has_obstacle_heading_threshold() {
  _has_bits_[0] &= ~0x00008000u;
}
void HomotopyClassPlanner::clear_obstacle_heading_threshold() {
  obstacle_heading_threshold_ = 0;
  clear_has_obstacle_heading_threshold();
}
 float HomotopyClassPlanner::obstacle_heading_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
  return obstacle_heading_threshold_;
}
 void HomotopyClassPlanner::set_obstacle_heading_threshold(float value) {
  set_has_obstacle_heading_threshold();
  obstacle_heading_threshold_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
}

// optional bool viapoints_all_candidates = 17;
bool HomotopyClassPlanner::has_viapoints_all_candidates() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void HomotopyClassPlanner::set_has_viapoints_all_candidates() {
  _has_bits_[0] |= 0x00010000u;
}
void HomotopyClassPlanner::clear_has_viapoints_all_candidates() {
  _has_bits_[0] &= ~0x00010000u;
}
void HomotopyClassPlanner::clear_viapoints_all_candidates() {
  viapoints_all_candidates_ = false;
  clear_has_viapoints_all_candidates();
}
 bool HomotopyClassPlanner::viapoints_all_candidates() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
  return viapoints_all_candidates_;
}
 void HomotopyClassPlanner::set_viapoints_all_candidates(bool value) {
  set_has_viapoints_all_candidates();
  viapoints_all_candidates_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
}

// optional bool visualize_hc_graph = 18;
bool HomotopyClassPlanner::has_visualize_hc_graph() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void HomotopyClassPlanner::set_has_visualize_hc_graph() {
  _has_bits_[0] |= 0x00020000u;
}
void HomotopyClassPlanner::clear_has_visualize_hc_graph() {
  _has_bits_[0] &= ~0x00020000u;
}
void HomotopyClassPlanner::clear_visualize_hc_graph() {
  visualize_hc_graph_ = false;
  clear_has_visualize_hc_graph();
}
 bool HomotopyClassPlanner::visualize_hc_graph() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
  return visualize_hc_graph_;
}
 void HomotopyClassPlanner::set_visualize_hc_graph(bool value) {
  set_has_visualize_hc_graph();
  visualize_hc_graph_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Recovery::kShrinkHorizonMinDurationFieldNumber;
const int Recovery::kOscillationRecoveryFieldNumber;
const int Recovery::kShrinkHorizonBackupFieldNumber;
const int Recovery::kOscillationVEpsFieldNumber;
const int Recovery::kOscillationOmegaEpsFieldNumber;
const int Recovery::kOscillationRecoveryMinDurationFieldNumber;
const int Recovery::kOscillationFilterDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Recovery::Recovery()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Recovery)
}

void Recovery::InitAsDefaultInstance() {
}

Recovery::Recovery(const Recovery& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Recovery)
}

void Recovery::SharedCtor() {
  _cached_size_ = 0;
  shrink_horizon_min_duration_ = false;
  oscillation_recovery_ = false;
  shrink_horizon_backup_ = false;
  oscillation_v_eps_ = 0;
  oscillation_omega_eps_ = 0;
  oscillation_recovery_min_duration_ = 0;
  oscillation_filter_duration_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Recovery::~Recovery() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Recovery)
  SharedDtor();
}

void Recovery::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Recovery::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Recovery::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Recovery_descriptor_;
}

const Recovery& Recovery::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Recovery* Recovery::default_instance_ = NULL;

Recovery* Recovery::New(::google::protobuf::Arena* arena) const {
  Recovery* n = new Recovery;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Recovery::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Recovery)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Recovery, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Recovery*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(oscillation_v_eps_, shrink_horizon_backup_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Recovery::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Recovery)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool shrink_horizon_min_duration = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shrink_horizon_min_duration_)));
          set_has_shrink_horizon_min_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_oscillation_recovery;
        break;
      }

      // optional bool oscillation_recovery = 2;
      case 2: {
        if (tag == 16) {
         parse_oscillation_recovery:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &oscillation_recovery_)));
          set_has_oscillation_recovery();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shrink_horizon_backup;
        break;
      }

      // optional bool shrink_horizon_backup = 3;
      case 3: {
        if (tag == 24) {
         parse_shrink_horizon_backup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shrink_horizon_backup_)));
          set_has_shrink_horizon_backup();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_oscillation_v_eps;
        break;
      }

      // optional double oscillation_v_eps = 4;
      case 4: {
        if (tag == 33) {
         parse_oscillation_v_eps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &oscillation_v_eps_)));
          set_has_oscillation_v_eps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_oscillation_omega_eps;
        break;
      }

      // optional double oscillation_omega_eps = 5;
      case 5: {
        if (tag == 41) {
         parse_oscillation_omega_eps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &oscillation_omega_eps_)));
          set_has_oscillation_omega_eps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_oscillation_recovery_min_duration;
        break;
      }

      // optional double oscillation_recovery_min_duration = 6;
      case 6: {
        if (tag == 49) {
         parse_oscillation_recovery_min_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &oscillation_recovery_min_duration_)));
          set_has_oscillation_recovery_min_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_oscillation_filter_duration;
        break;
      }

      // optional double oscillation_filter_duration = 7;
      case 7: {
        if (tag == 57) {
         parse_oscillation_filter_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &oscillation_filter_duration_)));
          set_has_oscillation_filter_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Recovery)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Recovery)
  return false;
#undef DO_
}

void Recovery::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Recovery)
  // optional bool shrink_horizon_min_duration = 1;
  if (has_shrink_horizon_min_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->shrink_horizon_min_duration(), output);
  }

  // optional bool oscillation_recovery = 2;
  if (has_oscillation_recovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->oscillation_recovery(), output);
  }

  // optional bool shrink_horizon_backup = 3;
  if (has_shrink_horizon_backup()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->shrink_horizon_backup(), output);
  }

  // optional double oscillation_v_eps = 4;
  if (has_oscillation_v_eps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->oscillation_v_eps(), output);
  }

  // optional double oscillation_omega_eps = 5;
  if (has_oscillation_omega_eps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->oscillation_omega_eps(), output);
  }

  // optional double oscillation_recovery_min_duration = 6;
  if (has_oscillation_recovery_min_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->oscillation_recovery_min_duration(), output);
  }

  // optional double oscillation_filter_duration = 7;
  if (has_oscillation_filter_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->oscillation_filter_duration(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Recovery)
}

::google::protobuf::uint8* Recovery::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Recovery)
  // optional bool shrink_horizon_min_duration = 1;
  if (has_shrink_horizon_min_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->shrink_horizon_min_duration(), target);
  }

  // optional bool oscillation_recovery = 2;
  if (has_oscillation_recovery()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->oscillation_recovery(), target);
  }

  // optional bool shrink_horizon_backup = 3;
  if (has_shrink_horizon_backup()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->shrink_horizon_backup(), target);
  }

  // optional double oscillation_v_eps = 4;
  if (has_oscillation_v_eps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->oscillation_v_eps(), target);
  }

  // optional double oscillation_omega_eps = 5;
  if (has_oscillation_omega_eps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->oscillation_omega_eps(), target);
  }

  // optional double oscillation_recovery_min_duration = 6;
  if (has_oscillation_recovery_min_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->oscillation_recovery_min_duration(), target);
  }

  // optional double oscillation_filter_duration = 7;
  if (has_oscillation_filter_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->oscillation_filter_duration(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Recovery)
  return target;
}

int Recovery::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Recovery)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional bool shrink_horizon_min_duration = 1;
    if (has_shrink_horizon_min_duration()) {
      total_size += 1 + 1;
    }

    // optional bool oscillation_recovery = 2;
    if (has_oscillation_recovery()) {
      total_size += 1 + 1;
    }

    // optional bool shrink_horizon_backup = 3;
    if (has_shrink_horizon_backup()) {
      total_size += 1 + 1;
    }

    // optional double oscillation_v_eps = 4;
    if (has_oscillation_v_eps()) {
      total_size += 1 + 8;
    }

    // optional double oscillation_omega_eps = 5;
    if (has_oscillation_omega_eps()) {
      total_size += 1 + 8;
    }

    // optional double oscillation_recovery_min_duration = 6;
    if (has_oscillation_recovery_min_duration()) {
      total_size += 1 + 8;
    }

    // optional double oscillation_filter_duration = 7;
    if (has_oscillation_filter_duration()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Recovery::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Recovery)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Recovery* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Recovery>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Recovery)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Recovery)
    MergeFrom(*source);
  }
}

void Recovery::MergeFrom(const Recovery& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Recovery)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shrink_horizon_min_duration()) {
      set_shrink_horizon_min_duration(from.shrink_horizon_min_duration());
    }
    if (from.has_oscillation_recovery()) {
      set_oscillation_recovery(from.oscillation_recovery());
    }
    if (from.has_shrink_horizon_backup()) {
      set_shrink_horizon_backup(from.shrink_horizon_backup());
    }
    if (from.has_oscillation_v_eps()) {
      set_oscillation_v_eps(from.oscillation_v_eps());
    }
    if (from.has_oscillation_omega_eps()) {
      set_oscillation_omega_eps(from.oscillation_omega_eps());
    }
    if (from.has_oscillation_recovery_min_duration()) {
      set_oscillation_recovery_min_duration(from.oscillation_recovery_min_duration());
    }
    if (from.has_oscillation_filter_duration()) {
      set_oscillation_filter_duration(from.oscillation_filter_duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Recovery::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Recovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Recovery::CopyFrom(const Recovery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Recovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Recovery::IsInitialized() const {

  return true;
}

void Recovery::Swap(Recovery* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Recovery::InternalSwap(Recovery* other) {
  std::swap(shrink_horizon_min_duration_, other->shrink_horizon_min_duration_);
  std::swap(oscillation_recovery_, other->oscillation_recovery_);
  std::swap(shrink_horizon_backup_, other->shrink_horizon_backup_);
  std::swap(oscillation_v_eps_, other->oscillation_v_eps_);
  std::swap(oscillation_omega_eps_, other->oscillation_omega_eps_);
  std::swap(oscillation_recovery_min_duration_, other->oscillation_recovery_min_duration_);
  std::swap(oscillation_filter_duration_, other->oscillation_filter_duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Recovery::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Recovery_descriptor_;
  metadata.reflection = Recovery_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Recovery

// optional bool shrink_horizon_min_duration = 1;
bool Recovery::has_shrink_horizon_min_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Recovery::set_has_shrink_horizon_min_duration() {
  _has_bits_[0] |= 0x00000001u;
}
void Recovery::clear_has_shrink_horizon_min_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
void Recovery::clear_shrink_horizon_min_duration() {
  shrink_horizon_min_duration_ = false;
  clear_has_shrink_horizon_min_duration();
}
 bool Recovery::shrink_horizon_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_min_duration)
  return shrink_horizon_min_duration_;
}
 void Recovery::set_shrink_horizon_min_duration(bool value) {
  set_has_shrink_horizon_min_duration();
  shrink_horizon_min_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_min_duration)
}

// optional bool oscillation_recovery = 2;
bool Recovery::has_oscillation_recovery() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Recovery::set_has_oscillation_recovery() {
  _has_bits_[0] |= 0x00000002u;
}
void Recovery::clear_has_oscillation_recovery() {
  _has_bits_[0] &= ~0x00000002u;
}
void Recovery::clear_oscillation_recovery() {
  oscillation_recovery_ = false;
  clear_has_oscillation_recovery();
}
 bool Recovery::oscillation_recovery() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery)
  return oscillation_recovery_;
}
 void Recovery::set_oscillation_recovery(bool value) {
  set_has_oscillation_recovery();
  oscillation_recovery_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery)
}

// optional bool shrink_horizon_backup = 3;
bool Recovery::has_shrink_horizon_backup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Recovery::set_has_shrink_horizon_backup() {
  _has_bits_[0] |= 0x00000004u;
}
void Recovery::clear_has_shrink_horizon_backup() {
  _has_bits_[0] &= ~0x00000004u;
}
void Recovery::clear_shrink_horizon_backup() {
  shrink_horizon_backup_ = false;
  clear_has_shrink_horizon_backup();
}
 bool Recovery::shrink_horizon_backup() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_backup)
  return shrink_horizon_backup_;
}
 void Recovery::set_shrink_horizon_backup(bool value) {
  set_has_shrink_horizon_backup();
  shrink_horizon_backup_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_backup)
}

// optional double oscillation_v_eps = 4;
bool Recovery::has_oscillation_v_eps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Recovery::set_has_oscillation_v_eps() {
  _has_bits_[0] |= 0x00000008u;
}
void Recovery::clear_has_oscillation_v_eps() {
  _has_bits_[0] &= ~0x00000008u;
}
void Recovery::clear_oscillation_v_eps() {
  oscillation_v_eps_ = 0;
  clear_has_oscillation_v_eps();
}
 double Recovery::oscillation_v_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_v_eps)
  return oscillation_v_eps_;
}
 void Recovery::set_oscillation_v_eps(double value) {
  set_has_oscillation_v_eps();
  oscillation_v_eps_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_v_eps)
}

// optional double oscillation_omega_eps = 5;
bool Recovery::has_oscillation_omega_eps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Recovery::set_has_oscillation_omega_eps() {
  _has_bits_[0] |= 0x00000010u;
}
void Recovery::clear_has_oscillation_omega_eps() {
  _has_bits_[0] &= ~0x00000010u;
}
void Recovery::clear_oscillation_omega_eps() {
  oscillation_omega_eps_ = 0;
  clear_has_oscillation_omega_eps();
}
 double Recovery::oscillation_omega_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_omega_eps)
  return oscillation_omega_eps_;
}
 void Recovery::set_oscillation_omega_eps(double value) {
  set_has_oscillation_omega_eps();
  oscillation_omega_eps_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_omega_eps)
}

// optional double oscillation_recovery_min_duration = 6;
bool Recovery::has_oscillation_recovery_min_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Recovery::set_has_oscillation_recovery_min_duration() {
  _has_bits_[0] |= 0x00000020u;
}
void Recovery::clear_has_oscillation_recovery_min_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
void Recovery::clear_oscillation_recovery_min_duration() {
  oscillation_recovery_min_duration_ = 0;
  clear_has_oscillation_recovery_min_duration();
}
 double Recovery::oscillation_recovery_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
  return oscillation_recovery_min_duration_;
}
 void Recovery::set_oscillation_recovery_min_duration(double value) {
  set_has_oscillation_recovery_min_duration();
  oscillation_recovery_min_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
}

// optional double oscillation_filter_duration = 7;
bool Recovery::has_oscillation_filter_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Recovery::set_has_oscillation_filter_duration() {
  _has_bits_[0] |= 0x00000040u;
}
void Recovery::clear_has_oscillation_filter_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
void Recovery::clear_oscillation_filter_duration() {
  oscillation_filter_duration_ = 0;
  clear_has_oscillation_filter_duration();
}
 double Recovery::oscillation_filter_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_filter_duration)
  return oscillation_filter_duration_;
}
 void Recovery::set_oscillation_filter_duration(double value) {
  set_has_oscillation_filter_duration();
  oscillation_filter_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_filter_duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Config::kOptFrameFieldNumber;
const int Config::kTrajectoryOptFieldNumber;
const int Config::kKinematicsOptFieldNumber;
const int Config::kToleranceOptFieldNumber;
const int Config::kObstaclesOptFieldNumber;
const int Config::kOptimizeInfoFieldNumber;
const int Config::kHcpOptFieldNumber;
const int Config::kRobotTypeFieldNumber;
const int Config::kRecoveryInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Config::Config()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:roborts_local_planner.Config)
}

void Config::InitAsDefaultInstance() {
  opt_frame_ = const_cast< ::roborts_local_planner::FrameID*>(&::roborts_local_planner::FrameID::default_instance());
  trajectory_opt_ = const_cast< ::roborts_local_planner::Trajectory*>(&::roborts_local_planner::Trajectory::default_instance());
  kinematics_opt_ = const_cast< ::roborts_local_planner::Robot*>(&::roborts_local_planner::Robot::default_instance());
  tolerance_opt_ = const_cast< ::roborts_local_planner::GoalTolerance*>(&::roborts_local_planner::GoalTolerance::default_instance());
  obstacles_opt_ = const_cast< ::roborts_local_planner::Obstacles*>(&::roborts_local_planner::Obstacles::default_instance());
  optimize_info_ = const_cast< ::roborts_local_planner::Optimization*>(&::roborts_local_planner::Optimization::default_instance());
  hcp_opt_ = const_cast< ::roborts_local_planner::HomotopyClassPlanner*>(&::roborts_local_planner::HomotopyClassPlanner::default_instance());
  recovery_info_ = const_cast< ::roborts_local_planner::Recovery*>(&::roborts_local_planner::Recovery::default_instance());
}

Config::Config(const Config& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:roborts_local_planner.Config)
}

void Config::SharedCtor() {
  _cached_size_ = 0;
  opt_frame_ = NULL;
  trajectory_opt_ = NULL;
  kinematics_opt_ = NULL;
  tolerance_opt_ = NULL;
  obstacles_opt_ = NULL;
  optimize_info_ = NULL;
  hcp_opt_ = NULL;
  recovery_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:roborts_local_planner.Config)
  SharedDtor();
}

void Config::SharedDtor() {
  if (this != default_instance_) {
    delete opt_frame_;
    delete trajectory_opt_;
    delete kinematics_opt_;
    delete tolerance_opt_;
    delete obstacles_opt_;
    delete optimize_info_;
    delete hcp_opt_;
    delete recovery_info_;
  }
}

void Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_descriptor_;
}

const Config& Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  return *default_instance_;
}

Config* Config::default_instance_ = NULL;

Config* Config::New(::google::protobuf::Arena* arena) const {
  Config* n = new Config;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Config::Clear() {
// @@protoc_insertion_point(message_clear_start:roborts_local_planner.Config)
  if (_has_bits_[0 / 32] & 127u) {
    if (has_opt_frame()) {
      if (opt_frame_ != NULL) opt_frame_->::roborts_local_planner::FrameID::Clear();
    }
    if (has_trajectory_opt()) {
      if (trajectory_opt_ != NULL) trajectory_opt_->::roborts_local_planner::Trajectory::Clear();
    }
    if (has_kinematics_opt()) {
      if (kinematics_opt_ != NULL) kinematics_opt_->::roborts_local_planner::Robot::Clear();
    }
    if (has_tolerance_opt()) {
      if (tolerance_opt_ != NULL) tolerance_opt_->::roborts_local_planner::GoalTolerance::Clear();
    }
    if (has_obstacles_opt()) {
      if (obstacles_opt_ != NULL) obstacles_opt_->::roborts_local_planner::Obstacles::Clear();
    }
    if (has_optimize_info()) {
      if (optimize_info_ != NULL) optimize_info_->::roborts_local_planner::Optimization::Clear();
    }
    if (has_hcp_opt()) {
      if (hcp_opt_ != NULL) hcp_opt_->::roborts_local_planner::HomotopyClassPlanner::Clear();
    }
  }
  if (has_recovery_info()) {
    if (recovery_info_ != NULL) recovery_info_->::roborts_local_planner::Recovery::Clear();
  }
  robot_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:roborts_local_planner.Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .roborts_local_planner.FrameID opt_frame = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_opt_frame()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_trajectory_opt;
        break;
      }

      // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
      case 2: {
        if (tag == 18) {
         parse_trajectory_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trajectory_opt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_kinematics_opt;
        break;
      }

      // optional .roborts_local_planner.Robot kinematics_opt = 3;
      case 3: {
        if (tag == 26) {
         parse_kinematics_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kinematics_opt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_tolerance_opt;
        break;
      }

      // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
      case 4: {
        if (tag == 34) {
         parse_tolerance_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tolerance_opt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_obstacles_opt;
        break;
      }

      // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
      case 5: {
        if (tag == 42) {
         parse_obstacles_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_obstacles_opt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_optimize_info;
        break;
      }

      // optional .roborts_local_planner.Optimization optimize_info = 6;
      case 6: {
        if (tag == 50) {
         parse_optimize_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_optimize_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_hcp_opt;
        break;
      }

      // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
      case 7: {
        if (tag == 58) {
         parse_hcp_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hcp_opt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_robot_type;
        break;
      }

      // repeated .roborts_local_planner.FootprintModel robot_type = 8;
      case 8: {
        if (tag == 66) {
         parse_robot_type:
          DO_(input->IncrementRecursionDepth());
         parse_loop_robot_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_robot_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_loop_robot_type;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(74)) goto parse_recovery_info;
        break;
      }

      // optional .roborts_local_planner.Recovery recovery_info = 9;
      case 9: {
        if (tag == 74) {
         parse_recovery_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_recovery_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:roborts_local_planner.Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:roborts_local_planner.Config)
  return false;
#undef DO_
}

void Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:roborts_local_planner.Config)
  // optional .roborts_local_planner.FrameID opt_frame = 1;
  if (has_opt_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->opt_frame_, output);
  }

  // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
  if (has_trajectory_opt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->trajectory_opt_, output);
  }

  // optional .roborts_local_planner.Robot kinematics_opt = 3;
  if (has_kinematics_opt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->kinematics_opt_, output);
  }

  // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
  if (has_tolerance_opt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->tolerance_opt_, output);
  }

  // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
  if (has_obstacles_opt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->obstacles_opt_, output);
  }

  // optional .roborts_local_planner.Optimization optimize_info = 6;
  if (has_optimize_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->optimize_info_, output);
  }

  // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
  if (has_hcp_opt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->hcp_opt_, output);
  }

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  for (unsigned int i = 0, n = this->robot_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->robot_type(i), output);
  }

  // optional .roborts_local_planner.Recovery recovery_info = 9;
  if (has_recovery_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->recovery_info_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:roborts_local_planner.Config)
}

::google::protobuf::uint8* Config::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:roborts_local_planner.Config)
  // optional .roborts_local_planner.FrameID opt_frame = 1;
  if (has_opt_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->opt_frame_, false, target);
  }

  // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
  if (has_trajectory_opt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->trajectory_opt_, false, target);
  }

  // optional .roborts_local_planner.Robot kinematics_opt = 3;
  if (has_kinematics_opt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->kinematics_opt_, false, target);
  }

  // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
  if (has_tolerance_opt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->tolerance_opt_, false, target);
  }

  // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
  if (has_obstacles_opt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->obstacles_opt_, false, target);
  }

  // optional .roborts_local_planner.Optimization optimize_info = 6;
  if (has_optimize_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->optimize_info_, false, target);
  }

  // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
  if (has_hcp_opt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->hcp_opt_, false, target);
  }

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  for (unsigned int i = 0, n = this->robot_type_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, this->robot_type(i), false, target);
  }

  // optional .roborts_local_planner.Recovery recovery_info = 9;
  if (has_recovery_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->recovery_info_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:roborts_local_planner.Config)
  return target;
}

int Config::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:roborts_local_planner.Config)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional .roborts_local_planner.FrameID opt_frame = 1;
    if (has_opt_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->opt_frame_);
    }

    // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
    if (has_trajectory_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->trajectory_opt_);
    }

    // optional .roborts_local_planner.Robot kinematics_opt = 3;
    if (has_kinematics_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kinematics_opt_);
    }

    // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
    if (has_tolerance_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->tolerance_opt_);
    }

    // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
    if (has_obstacles_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->obstacles_opt_);
    }

    // optional .roborts_local_planner.Optimization optimize_info = 6;
    if (has_optimize_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->optimize_info_);
    }

    // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
    if (has_hcp_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->hcp_opt_);
    }

  }
  // optional .roborts_local_planner.Recovery recovery_info = 9;
  if (has_recovery_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->recovery_info_);
  }

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  total_size += 1 * this->robot_type_size();
  for (int i = 0; i < this->robot_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->robot_type(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Config::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:roborts_local_planner.Config)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Config* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Config>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:roborts_local_planner.Config)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:roborts_local_planner.Config)
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:roborts_local_planner.Config)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  robot_type_.MergeFrom(from.robot_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_opt_frame()) {
      mutable_opt_frame()->::roborts_local_planner::FrameID::MergeFrom(from.opt_frame());
    }
    if (from.has_trajectory_opt()) {
      mutable_trajectory_opt()->::roborts_local_planner::Trajectory::MergeFrom(from.trajectory_opt());
    }
    if (from.has_kinematics_opt()) {
      mutable_kinematics_opt()->::roborts_local_planner::Robot::MergeFrom(from.kinematics_opt());
    }
    if (from.has_tolerance_opt()) {
      mutable_tolerance_opt()->::roborts_local_planner::GoalTolerance::MergeFrom(from.tolerance_opt());
    }
    if (from.has_obstacles_opt()) {
      mutable_obstacles_opt()->::roborts_local_planner::Obstacles::MergeFrom(from.obstacles_opt());
    }
    if (from.has_optimize_info()) {
      mutable_optimize_info()->::roborts_local_planner::Optimization::MergeFrom(from.optimize_info());
    }
    if (from.has_hcp_opt()) {
      mutable_hcp_opt()->::roborts_local_planner::HomotopyClassPlanner::MergeFrom(from.hcp_opt());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_recovery_info()) {
      mutable_recovery_info()->::roborts_local_planner::Recovery::MergeFrom(from.recovery_info());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Config::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:roborts_local_planner.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:roborts_local_planner.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {

  return true;
}

void Config::Swap(Config* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Config::InternalSwap(Config* other) {
  std::swap(opt_frame_, other->opt_frame_);
  std::swap(trajectory_opt_, other->trajectory_opt_);
  std::swap(kinematics_opt_, other->kinematics_opt_);
  std::swap(tolerance_opt_, other->tolerance_opt_);
  std::swap(obstacles_opt_, other->obstacles_opt_);
  std::swap(optimize_info_, other->optimize_info_);
  std::swap(hcp_opt_, other->hcp_opt_);
  robot_type_.UnsafeArenaSwap(&other->robot_type_);
  std::swap(recovery_info_, other->recovery_info_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Config_descriptor_;
  metadata.reflection = Config_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Config

// optional .roborts_local_planner.FrameID opt_frame = 1;
bool Config::has_opt_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Config::set_has_opt_frame() {
  _has_bits_[0] |= 0x00000001u;
}
void Config::clear_has_opt_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
void Config::clear_opt_frame() {
  if (opt_frame_ != NULL) opt_frame_->::roborts_local_planner::FrameID::Clear();
  clear_has_opt_frame();
}
const ::roborts_local_planner::FrameID& Config::opt_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.opt_frame)
  return opt_frame_ != NULL ? *opt_frame_ : *default_instance_->opt_frame_;
}
::roborts_local_planner::FrameID* Config::mutable_opt_frame() {
  set_has_opt_frame();
  if (opt_frame_ == NULL) {
    opt_frame_ = new ::roborts_local_planner::FrameID;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.opt_frame)
  return opt_frame_;
}
::roborts_local_planner::FrameID* Config::release_opt_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.opt_frame)
  clear_has_opt_frame();
  ::roborts_local_planner::FrameID* temp = opt_frame_;
  opt_frame_ = NULL;
  return temp;
}
void Config::set_allocated_opt_frame(::roborts_local_planner::FrameID* opt_frame) {
  delete opt_frame_;
  opt_frame_ = opt_frame;
  if (opt_frame) {
    set_has_opt_frame();
  } else {
    clear_has_opt_frame();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.opt_frame)
}

// optional .roborts_local_planner.Trajectory trajectory_opt = 2;
bool Config::has_trajectory_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Config::set_has_trajectory_opt() {
  _has_bits_[0] |= 0x00000002u;
}
void Config::clear_has_trajectory_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
void Config::clear_trajectory_opt() {
  if (trajectory_opt_ != NULL) trajectory_opt_->::roborts_local_planner::Trajectory::Clear();
  clear_has_trajectory_opt();
}
const ::roborts_local_planner::Trajectory& Config::trajectory_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.trajectory_opt)
  return trajectory_opt_ != NULL ? *trajectory_opt_ : *default_instance_->trajectory_opt_;
}
::roborts_local_planner::Trajectory* Config::mutable_trajectory_opt() {
  set_has_trajectory_opt();
  if (trajectory_opt_ == NULL) {
    trajectory_opt_ = new ::roborts_local_planner::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.trajectory_opt)
  return trajectory_opt_;
}
::roborts_local_planner::Trajectory* Config::release_trajectory_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.trajectory_opt)
  clear_has_trajectory_opt();
  ::roborts_local_planner::Trajectory* temp = trajectory_opt_;
  trajectory_opt_ = NULL;
  return temp;
}
void Config::set_allocated_trajectory_opt(::roborts_local_planner::Trajectory* trajectory_opt) {
  delete trajectory_opt_;
  trajectory_opt_ = trajectory_opt;
  if (trajectory_opt) {
    set_has_trajectory_opt();
  } else {
    clear_has_trajectory_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.trajectory_opt)
}

// optional .roborts_local_planner.Robot kinematics_opt = 3;
bool Config::has_kinematics_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Config::set_has_kinematics_opt() {
  _has_bits_[0] |= 0x00000004u;
}
void Config::clear_has_kinematics_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
void Config::clear_kinematics_opt() {
  if (kinematics_opt_ != NULL) kinematics_opt_->::roborts_local_planner::Robot::Clear();
  clear_has_kinematics_opt();
}
const ::roborts_local_planner::Robot& Config::kinematics_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.kinematics_opt)
  return kinematics_opt_ != NULL ? *kinematics_opt_ : *default_instance_->kinematics_opt_;
}
::roborts_local_planner::Robot* Config::mutable_kinematics_opt() {
  set_has_kinematics_opt();
  if (kinematics_opt_ == NULL) {
    kinematics_opt_ = new ::roborts_local_planner::Robot;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.kinematics_opt)
  return kinematics_opt_;
}
::roborts_local_planner::Robot* Config::release_kinematics_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.kinematics_opt)
  clear_has_kinematics_opt();
  ::roborts_local_planner::Robot* temp = kinematics_opt_;
  kinematics_opt_ = NULL;
  return temp;
}
void Config::set_allocated_kinematics_opt(::roborts_local_planner::Robot* kinematics_opt) {
  delete kinematics_opt_;
  kinematics_opt_ = kinematics_opt;
  if (kinematics_opt) {
    set_has_kinematics_opt();
  } else {
    clear_has_kinematics_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.kinematics_opt)
}

// optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
bool Config::has_tolerance_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Config::set_has_tolerance_opt() {
  _has_bits_[0] |= 0x00000008u;
}
void Config::clear_has_tolerance_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
void Config::clear_tolerance_opt() {
  if (tolerance_opt_ != NULL) tolerance_opt_->::roborts_local_planner::GoalTolerance::Clear();
  clear_has_tolerance_opt();
}
const ::roborts_local_planner::GoalTolerance& Config::tolerance_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.tolerance_opt)
  return tolerance_opt_ != NULL ? *tolerance_opt_ : *default_instance_->tolerance_opt_;
}
::roborts_local_planner::GoalTolerance* Config::mutable_tolerance_opt() {
  set_has_tolerance_opt();
  if (tolerance_opt_ == NULL) {
    tolerance_opt_ = new ::roborts_local_planner::GoalTolerance;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.tolerance_opt)
  return tolerance_opt_;
}
::roborts_local_planner::GoalTolerance* Config::release_tolerance_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.tolerance_opt)
  clear_has_tolerance_opt();
  ::roborts_local_planner::GoalTolerance* temp = tolerance_opt_;
  tolerance_opt_ = NULL;
  return temp;
}
void Config::set_allocated_tolerance_opt(::roborts_local_planner::GoalTolerance* tolerance_opt) {
  delete tolerance_opt_;
  tolerance_opt_ = tolerance_opt;
  if (tolerance_opt) {
    set_has_tolerance_opt();
  } else {
    clear_has_tolerance_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.tolerance_opt)
}

// optional .roborts_local_planner.Obstacles obstacles_opt = 5;
bool Config::has_obstacles_opt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Config::set_has_obstacles_opt() {
  _has_bits_[0] |= 0x00000010u;
}
void Config::clear_has_obstacles_opt() {
  _has_bits_[0] &= ~0x00000010u;
}
void Config::clear_obstacles_opt() {
  if (obstacles_opt_ != NULL) obstacles_opt_->::roborts_local_planner::Obstacles::Clear();
  clear_has_obstacles_opt();
}
const ::roborts_local_planner::Obstacles& Config::obstacles_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.obstacles_opt)
  return obstacles_opt_ != NULL ? *obstacles_opt_ : *default_instance_->obstacles_opt_;
}
::roborts_local_planner::Obstacles* Config::mutable_obstacles_opt() {
  set_has_obstacles_opt();
  if (obstacles_opt_ == NULL) {
    obstacles_opt_ = new ::roborts_local_planner::Obstacles;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.obstacles_opt)
  return obstacles_opt_;
}
::roborts_local_planner::Obstacles* Config::release_obstacles_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.obstacles_opt)
  clear_has_obstacles_opt();
  ::roborts_local_planner::Obstacles* temp = obstacles_opt_;
  obstacles_opt_ = NULL;
  return temp;
}
void Config::set_allocated_obstacles_opt(::roborts_local_planner::Obstacles* obstacles_opt) {
  delete obstacles_opt_;
  obstacles_opt_ = obstacles_opt;
  if (obstacles_opt) {
    set_has_obstacles_opt();
  } else {
    clear_has_obstacles_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.obstacles_opt)
}

// optional .roborts_local_planner.Optimization optimize_info = 6;
bool Config::has_optimize_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Config::set_has_optimize_info() {
  _has_bits_[0] |= 0x00000020u;
}
void Config::clear_has_optimize_info() {
  _has_bits_[0] &= ~0x00000020u;
}
void Config::clear_optimize_info() {
  if (optimize_info_ != NULL) optimize_info_->::roborts_local_planner::Optimization::Clear();
  clear_has_optimize_info();
}
const ::roborts_local_planner::Optimization& Config::optimize_info() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.optimize_info)
  return optimize_info_ != NULL ? *optimize_info_ : *default_instance_->optimize_info_;
}
::roborts_local_planner::Optimization* Config::mutable_optimize_info() {
  set_has_optimize_info();
  if (optimize_info_ == NULL) {
    optimize_info_ = new ::roborts_local_planner::Optimization;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.optimize_info)
  return optimize_info_;
}
::roborts_local_planner::Optimization* Config::release_optimize_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.optimize_info)
  clear_has_optimize_info();
  ::roborts_local_planner::Optimization* temp = optimize_info_;
  optimize_info_ = NULL;
  return temp;
}
void Config::set_allocated_optimize_info(::roborts_local_planner::Optimization* optimize_info) {
  delete optimize_info_;
  optimize_info_ = optimize_info;
  if (optimize_info) {
    set_has_optimize_info();
  } else {
    clear_has_optimize_info();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.optimize_info)
}

// optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
bool Config::has_hcp_opt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Config::set_has_hcp_opt() {
  _has_bits_[0] |= 0x00000040u;
}
void Config::clear_has_hcp_opt() {
  _has_bits_[0] &= ~0x00000040u;
}
void Config::clear_hcp_opt() {
  if (hcp_opt_ != NULL) hcp_opt_->::roborts_local_planner::HomotopyClassPlanner::Clear();
  clear_has_hcp_opt();
}
const ::roborts_local_planner::HomotopyClassPlanner& Config::hcp_opt() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.hcp_opt)
  return hcp_opt_ != NULL ? *hcp_opt_ : *default_instance_->hcp_opt_;
}
::roborts_local_planner::HomotopyClassPlanner* Config::mutable_hcp_opt() {
  set_has_hcp_opt();
  if (hcp_opt_ == NULL) {
    hcp_opt_ = new ::roborts_local_planner::HomotopyClassPlanner;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.hcp_opt)
  return hcp_opt_;
}
::roborts_local_planner::HomotopyClassPlanner* Config::release_hcp_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.hcp_opt)
  clear_has_hcp_opt();
  ::roborts_local_planner::HomotopyClassPlanner* temp = hcp_opt_;
  hcp_opt_ = NULL;
  return temp;
}
void Config::set_allocated_hcp_opt(::roborts_local_planner::HomotopyClassPlanner* hcp_opt) {
  delete hcp_opt_;
  hcp_opt_ = hcp_opt;
  if (hcp_opt) {
    set_has_hcp_opt();
  } else {
    clear_has_hcp_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.hcp_opt)
}

// repeated .roborts_local_planner.FootprintModel robot_type = 8;
int Config::robot_type_size() const {
  return robot_type_.size();
}
void Config::clear_robot_type() {
  robot_type_.Clear();
}
const ::roborts_local_planner::FootprintModel& Config::robot_type(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.robot_type)
  return robot_type_.Get(index);
}
::roborts_local_planner::FootprintModel* Config::mutable_robot_type(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.robot_type)
  return robot_type_.Mutable(index);
}
::roborts_local_planner::FootprintModel* Config::add_robot_type() {
  // @@protoc_insertion_point(field_add:roborts_local_planner.Config.robot_type)
  return robot_type_.Add();
}
::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >*
Config::mutable_robot_type() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.Config.robot_type)
  return &robot_type_;
}
const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >&
Config::robot_type() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.Config.robot_type)
  return robot_type_;
}

// optional .roborts_local_planner.Recovery recovery_info = 9;
bool Config::has_recovery_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Config::set_has_recovery_info() {
  _has_bits_[0] |= 0x00000100u;
}
void Config::clear_has_recovery_info() {
  _has_bits_[0] &= ~0x00000100u;
}
void Config::clear_recovery_info() {
  if (recovery_info_ != NULL) recovery_info_->::roborts_local_planner::Recovery::Clear();
  clear_has_recovery_info();
}
const ::roborts_local_planner::Recovery& Config::recovery_info() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.recovery_info)
  return recovery_info_ != NULL ? *recovery_info_ : *default_instance_->recovery_info_;
}
::roborts_local_planner::Recovery* Config::mutable_recovery_info() {
  set_has_recovery_info();
  if (recovery_info_ == NULL) {
    recovery_info_ = new ::roborts_local_planner::Recovery;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.recovery_info)
  return recovery_info_;
}
::roborts_local_planner::Recovery* Config::release_recovery_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.recovery_info)
  clear_has_recovery_info();
  ::roborts_local_planner::Recovery* temp = recovery_info_;
  recovery_info_ = NULL;
  return temp;
}
void Config::set_allocated_recovery_info(::roborts_local_planner::Recovery* recovery_info) {
  delete recovery_info_;
  recovery_info_ = recovery_info;
  if (recovery_info) {
    set_has_recovery_info();
  } else {
    clear_has_recovery_info();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.recovery_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_local_planner

// @@protoc_insertion_point(global_scope)
